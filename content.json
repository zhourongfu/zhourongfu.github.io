{"meta":{"title":"AlexZhou","subtitle":"This is Aexl blog","description":"msbgn blog","author":"Rongfu Zhou","url":""},"pages":[{"title":"历程","date":"2016-10-20T11:58:53.000Z","updated":"2016-11-01T07:20:01.123Z","comments":true,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"date: 2016-10-20 19:58:55今天是我的hexo博客第一天上线，希望各位多多支持.本站以分享运维技术为主，欢迎大家参与技术分享，同时也欢迎大家吐槽，本站提供以下交流圈：QQ群①:115217248 QQ群②: 115227653"},{"title":"","date":"2016-12-09T08:04:22.767Z","updated":"2016-12-09T08:04:22.763Z","comments":true,"path":"python/index.html","permalink":"/python/index.html","excerpt":"","text":"Python之路 声明所有的文章作为速查笔记，以下文章正在更新，待完成更新之后会重新整理，欢迎收藏。 基础篇 我和python的第一次接触 python的数据类型（1） python的字符串续及列表 python运算符 python流程控制语句及练习题 一个打了激素的数组 python带着枷锁的列表 python列表练习讲解 python集合 Map Zip python内置函数以及Lambda表达式 进阶篇 Python系列之文件操作 Python系列之递归 Python系列之冒泡算法 Python系列之装饰器 Python系列之正则表达式re模块 Python系列之字符串格式化 Python系列之迭代器与生成器 Python系列之反射 Python系列之单例设计模式 Python系列之异常处理 面向对象篇 Python系列之异常处理 Python系列之面向对象进阶及类成员 Python系列之面向对象成员修饰符 Python系列之面向对象特殊成员 Python系列之面向对象Python2.7类继承"}],"posts":[{"title":"ELK添加Shield插件管理权限","slug":"ELKShield","date":"2016-12-15T07:15:05.363Z","updated":"2016-12-15T07:15:05.363Z","comments":true,"path":"2016/12/15/ELKShield/","link":"","permalink":"/2016/12/15/ELKShield/","excerpt":"","text":"ShieldShield作为插件安装到elasticsearch中，一旦安装，插件会拦截入栈API调用，以强制执行身份验证和授权，插件还可以使用Secure Sockets Layer/Transport Layer Security (SSL/TLS)为来自网络和elasticsearch的网络流量提供加密，该插件还是用API拦截层，该层使身份验证和授权能够提供审计日志记录功能。 为什么要使用ShieldELK是一个开源的日志分析平台，可以对各类日志进行分析和研究，但是有一个缺陷就是无法对用户身份进行验证，造成的直接后果就是任何人都可以访问和查看数据，从而我们需要这样一个插件来对elk的访问做一个权限控制，elastic官方给出的是使用shield，当然也有开源的产品替代search-guard，下边我们就先来看下elastic官方给出的shield在elk中的使用。 环境说明Centos6.5：16.04Elasticsearch：2.4.0Logstash：2.4.0Kibana：4.6.1Java：1.8.0_101 安装Shield到Elasticsearch12bin/plugin install licensebin/plugin install shield 测试安装是否成功Curl -X GET http://loclahost:9200 如果报错类似于下面这样，说明安装成功{“error”:{“root_cause”:[{“type”:”security_exception”,”reason”:”missing authentication token 创建一个es_admin用户，用来登录elasticsearch,kiabna超级管理员，按提示输入密码 12cd /usr/local/logstash-2.4.0/bin/shield/esusers useradd es_admin -r admin 2.安装Logstash（日志收集、分析，并将其存储供以后使用）这里安装遇到了下载的坑，最好去使用迅雷下载安装包 12wget https://download.elastic.co/logstash/logstash/logstash-2.4.0.tar.gztar –zxf logstash-2.4.0.tar.gz -C /usr/local/ 用新建的用户名进行测试 curl -u es_admin:password -X GET http://localhost:9200 12345678910111213&#123; \"name\" : \"Mauvais\", \"cluster_name\" : \"elasticsearch\", \"version\" : &#123; \"number\" : \"2.4.0\", \"build_hash\" : \"ce9f0c7394dee074091dd1bc4e9469251181fc55\", \"build_timestamp\" : \"2016-08-29T09:14:17Z\", \"build_snapshot\" : false, \"lucene_version\" : \"5.5.2\" &#125;, \"tagline\" : \"You Know, for Search\"&#125;OK Kibana添加用户权限为了给kibana加用户访问权限，同时为让kibana可以访问elasticsearch的数据，需要给kibana添加kibana server密码创建一个用户用来访问elasticsearch 1234/usr/local/logstash-2.4.0bin/shield/esusers useradd kibana4-server -r kibana4_serverEnter new password: 输入密码Retype new password: 接下来是比较重要的一个环节 利用openssl创建 server.key ，server.crt ，serverpem切换到kibana的目录，创建server_ssl目录，进入该目录创建所需的文件Key生成 12openssl genrsa -des3 -out server.key 2048openssl rsa -in server.key -out server.key 生成CA的Crt： 12openssl req -new -x509 -key server.key -out ca.crt -days 3650openssl req -new -key server.key -out server.csr Crt生成： 12openssl x509 -req -days 3650 -in server.csr -CA ca.crt -CAkey server.key -CAcreateserial -out server.crtcat server.key server.crt &gt; server.pem 最后在server_sll目录下有这些文件 1ca.crt ca.srl server.crt server.csr server.key server.pem 配置Kibana进入kibana的安装目录，执行：vim config/kibana.yml 指定访问elasticsearch的用户和密码12elasticsearch.username: \"kibana4-server\"elasticsearch.password: \"kibana\" 设置server.ssl.key /server.ssl.crt/serve.pem123server.ssl.cert: /usr/local/elasticsearch-2.2.0/server.crtserver.ssl.key: /usr/local/elasticsearch-2.2.0/server.keyelasticsearch.ssl.ca: /usr/local/elasticsearch-2.2.0/server.pem 设置elasticsearch.url1elasticsearch.url: http://192.168.10.110:9200 设置shield.encryptionKey1hield.encryptionKey: \"something_at_least_32_characters\" 设置shield.sessionTimeout1shield.sessionTimeout: 600000 在kibana中安装Shield1bin/kibana plugin –install kibana/shield/latest 如果提示安装不了，请去官网下载复制到kibana目录我分享的云盘地址 http://pan.baidu.com/s/1hrThpUO Roles.yml文件的配置roles.yml的位置 1/usr/local/elasticsearch-2.4.0/config/shield/roles.yml 我们拿其中一个举例说一下 12345678910111213141516171819202122232425#The required permissions for the kibana 4 serverkibana4_server: #用户组 cluster: - monitor indices: #权限 - names: '.kibana*' #索引名称 privileges: #用户可对该索引执行的操作 - all #这里是给隶属于kibana4_server的用户所有的执行权限 - names: '.reporting-*' privileges: - all编辑roles.yml，添加用户组 my_kibana_user 用户组，这里只给了read的权限my_kibana_user: cluster: - monitor indices: - names: 'logstash-*' privileges: - view_index_metadata - read - names: '.kibana*' privileges: - manage - read - index 接下来创建一个kibana属于my_kibana_user用户组 1234Cd /usr/local/elasticsearch-2.4.0/config/shield//usr/local/elasticsearch-2.4.0/bin/shield/esusers useradd kibana -r my_kibana_user/ usr / local /elasticsearch-2.4.0/bin/shield/esusers list logstash配置Shield创建一个logstash用户，用来连接elasticsearch 1234Cd /usr/ local /elasticsearch-2.4.0 bin/shield/esusers useradd logstash -r logstashEnter new password:Retype new password: 接着我们依旧测试Rsyslog发送日志在logstash目录下便捷logstash-indexer.conf，加入 1234567891011121314151617181920input &#123; file &#123; type =&gt; \"syslog\" path =&gt; [\"/var/log/messages\", \"/var/log/secure\" ] &#125; syslog &#123; type =&gt; \"syslog\" port =&gt; \"5542\" &#125;&#125;output &#123; elasticsearch &#123; hosts =&gt; 192.168.1.3\" user =&gt; \" es_admin \" #logstash与elasticsearch交互的用户名 这个用户名如果你不是单台部署的话用户名最好写 password =&gt; \"123456\" #这个是logsatsh对应的密码&#125; stdout &#123; codec =&gt; rubydebug &#125;&#125; 配置logstash-indexer的配置文件启动ELK，进行测试至此我们的整体环境已经编辑OK，使用es_admin登录，该用户所属用户组为admin，对elk有所有的执行权限 输入 https://192.168.10.110:5601 遇到问题是权限访问不到，后面配置logstash账号的时候使用es_admin就OK了 1[403] &#123;\"error\":&#123;\"root_cause\":[&#123;\"type\":\"security_exception\",\"reason\":\"action [indices:data/write/bulk] is unauthorized for user [logstash]\"&#125;],\"type\":\"security_exception\",\"reason\":\"action [indices:data/write/bulk] is unauthorized for user [logstash]\"&#125;,\"status\":403&#125; &#123;:class=&gt;\"Elasticsearch::Transport::Transport::Errors::Forbidden\", :backtrace=&gt;[\"/usr/local/logstash/vendor/bundle/jruby/1.9/gems/elasticsearch-transport-1.1.0/lib/elasticsearch/transport/transport/base.rb:201:in `__raise_transport_error'\", \"/usr/local/logstash/vendor/bundle/jruby/1.9/gems/elasticsearch-transport-1.1.0/lib/elasticsearch/transport/transport/base.rb:312:in `perform_request'\", \"/usr/local/logstash/vendor/bundle/jruby/1.9/gems/elasticsearch-transport-1.1.0/lib/elasticsearch/transport/transport/http/manticore.rb:67:in `perform_request'\", \"/usr/local/logstash/vendor/bundle/jruby/1.9/gems/elasticsearch-transport-1.1.0/lib/elasticsearch/transport/client.rb:128:in `perform_request'\", \"/usr/local/logstash/vendor/bundle/jruby/1.9/gems/elasticsearch-api-1.1.0/lib/elasticsearch/api/actions/bulk.rb:93:in `bulk'\", \"/usr/local/logstash/vendor/bundle/jruby/1.9/gems/logstash-output-elasticsearch-2.7.1-java/lib/logstash/outputs/elasticsearch/http_client.rb:53:in `non_threadsafe_bulk'\", \"/usr/local/logstash/vendor/bundle/jruby/1.9/gems/logstash-output-elasticsearch-2.7.1-java/lib/logstash/outputs/elasticsearch/http_client.rb:38:in `bulk'\", \"org/jruby/ext/thread/Mutex.java:149:in `synchronize'\", \"/usr/local/logstash/vendor/bundle/jruby/1.9/gems/logstash-output-elasticsearch-2.7.1-java/lib/logstash/outputs/elasticsearch/http_client.rb:38:in `bulk'\", \"/usr/local/logstash/vendor/bundle/jruby/1.9/gems/logstash-output-elasticsearch-2.7.1-java/lib/logstash/outputs/elasticsearch/common.rb:172:in `safe_bulk'\", \"/usr/local/logstash/vendor/bundle/jruby/1.9/gems/logstash-output-elasticsearch-2.7.1-java/lib/logstash/outputs/elasticsearch/common.rb:101:in `submit'\", \"/usr/local/logstash/vendor/bundle/jruby/1.9/gems/logstash-output-elasticsearch-2.7.1-java/lib/logstash/outputs/elasticsearch/common.rb:86:in `retrying_submit'\", \"/usr/local/logstash/vendor/bundle/jruby/1.9/gems/logstash-output-elasticsearch-2.7.1-java/lib/logstash/outputs/elasticsearch/common.rb:29:in `multi_receive'\", \"org/jruby/RubyArray.java:1653:in `each_slice'\", \"/usr/local/logstash/vendor/bundle/jruby/1.9/gems/logstash-output-elasticsearch-2.7.1-java/lib/logstash/outputs/elasticsearch/common.rb:28:in `multi_receive'\", \"/usr/local/logstash/vendor/bundle/jruby/1.9/gems/logstash-core-2.4.0-java/lib/logstash/output_delegator.rb:130:in `worker_multi_receive'\", \"/usr/local/logstash/vendor/bundle/jruby/1.9/gems/logstash-core-2.4.0-java/lib/logstash/output_delegator.rb:114:in `multi_receive'\", \"/usr/local/logstash/vendor/bundle/jruby/1.9/gems/logstash-core-2.4.0-java/lib/logstash/pipeline.rb:301:in `output_batch'\", \"org/jruby/RubyHash.java:1342:in `each'\", \"/usr/local/logstash/vendor/bundle/jruby/1.9/gems/logstash-core-2.4.0-java/lib/logstash/pipeline.rb:301:in `output_batch'\", \"/usr/local/logstash/vendor/bundle/jruby/1.9/gems/logstash-core-2.4.0-java/lib/logstash/pipeline.rb:232:in `worker_loop'\", 然后普通账号登录访问就是如下图","categories":[{"name":"ELK","slug":"ELK","permalink":"/categories/ELK/"}],"tags":[{"name":"语言","slug":"语言","permalink":"/tags/语言/"},{"name":"ELK","slug":"ELK","permalink":"/tags/ELK/"}],"keywords":[{"name":"ELK","slug":"ELK","permalink":"/categories/ELK/"}]},{"title":"elk实时日志分析平台搭建详细过程","slug":"elk1","date":"2016-12-15T06:55:30.547Z","updated":"2016-12-15T06:55:30.547Z","comments":true,"path":"2016/12/15/elk1/","link":"","permalink":"/2016/12/15/elk1/","excerpt":"","text":"ElasticsearchElasticsearch 是个开源分布式搜索引擎，它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。Logstash 是一个完全开源的工具，他可以对你的日志进行收集、分析，并将其存储供以后使用（如，搜索）kibana 也是一个开源和免费的工具，他Kibana可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助您汇总、分析和搜索重要数据日志。 服务端软件Elasticsearch：负责日志检索和分析，它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等Logstash：对日志进行收集、过滤，并将其存储供以后使用（如，搜索日志）Kibana：为日志分析提供友好的Web界面，可以帮助汇总、分析和搜索重要数据日志 客户端软件在需要收集日志的所有服务上部署logstash，作为logstash agent（logstash shipper）用于监控并过滤收集日志，将过滤后的内容发送到logstash indexer，logstash indexer将日志收集在一起交给全文搜索服务ElasticSearch，可以用ElasticSearch进行自定义搜索，然后通过Kibana来结合自定义搜索进行页面展示。192.168.50.119：ELK+Nginx192.168.50.120：Redis+Logstash 部署流程：1.安装JDKLogstash的运行依赖于Java运行环境， Logstash 1.5以上版本不低于java 7推荐使用最新版本的Java，我这里使用了1.8版本我们只需要Java的运行环境，所以可以只安装JRE，不过这里我依然使用JDK，请自行搜索安装。 1234567#rpm -ivh jdk-8u25-linux-x64.rpm vim /etc/profile #设置环境变量export JAVA_HOME=/usr/local/jdk1.8.0_45export PATH=$PATH:$JAVA_HOME/binexport CLASSPATH=.:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:$CLASSPATHsource /etc/profile #使环境变量生效 1234java -versionjava version \"1.8.0_25\"Java(TM) SE Runtime Environment (build 1.8.0_25-b17)Java HotSpot(TM) 64-Bit Server VM (build 25.25-b02, mixed mode) 2.安装Logstash（日志收集、分析，并将其存储供以后使用）这里安装遇到了下载的坑，最好去使用迅雷下载安装包 12wget https://download.elastic.co/logstash/logstash/logstash-2.4.0.tar.gztar –zxf logstash-2.4.0.tar.gz -C /usr/local/ 验证logstash是否安装成功 12345[root@localhost ~]# /usr/local/logstash-2.4.0/bin/logstash -e 'input &#123; stdin &#123; &#125; &#125; output &#123; stdout &#123;&#125; &#125;'Settings: Default pipeline workers: 1Logstash startup completed等待输入:hello world2016-11-28T20:32:07.853Z localhost.localdomain hello world 3.部署nginx并收集日志 123456yum -y install nginx设置nginx的log 格式vim /etc/nginx/nginx.conf log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" $http_x_forwarded_for $request_length $msec $connection_requests $request_time'; 系统安装了nginx就跳过此步骤 1service nginx start 12345678910111213141516171819mkdir /usr/local/logstash-2.4.0/conf/ #创建logstash配置目录定义logstash配置文件，用来收集nginx日志[root@localhost conf]# cat logstash_nginx.conf input &#123; file &#123; path =&gt; [\"/var/log/nginx/access.log\"] type =&gt; \"nginx_log\" &#125;&#125;output &#123; redis&#123; host =&gt; \"192.168.50.120\" key =&gt; 'logstash-redis' data_type =&gt; 'list' &#125; stdout &#123;codec =&gt; rubydebug &#125;&#125; 4.安装部署redis 192.168.50.120 服务器 123456yum -y install redisvim /etc/redis.confbind 192.168.50.120service redis start 5.启动Logstash 12[root@localhost conf]# /usr/local/logstash-2.4.0/bin/logstash -f ./logstash_nginx.conf --configtest #检查配置文件Configuration OK 1234567891011121314151617181920212223242526272829303132[root@localhost conf]# /usr/local/logstash-2.4.0/bin/logstash agent -f ./logstash_nginx.conf #将日志信息输出到redis服务器Settings: Default pipeline workers: 1Logstash startup completed&#123; \"message\" =&gt; \"192.168.50.114 - - [29/Nov/2016:00:58:43 +0800] \\\"GET / HTTP/1.1\\\" 304 0 \\\"-\\\" \\\"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36\\\" \\\"-\\\"\", \"@version\" =&gt; \"1\", \"@timestamp\" =&gt; \"2016-11-28T18:55:49.587Z\", \"path\" =&gt; \"/var/log/nginx/access.log\", \"host\" =&gt; \"localhost.localdomain\", \"type\" =&gt; \"nginx_log\"&#125;&#123; \"message\" =&gt; \"192.168.50.114 - - [29/Nov/2016:00:58:43 +0800] \\\"GET /nginx-logo.png HTTP/1.1\\\" 304 0 \\\"http://192.168.50.119/\\\" \\\"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36\\\" \\\"-\\\"\", \"@version\" =&gt; \"1\", \"@timestamp\" =&gt; \"2016-11-28T18:55:49.590Z\", \"path\" =&gt; \"/var/log/nginx/access.log\", \"host\" =&gt; \"localhost.localdomain\", \"type\" =&gt; \"nginx_log\"&#125;&#123; \"message\" =&gt; \"192.168.50.114 - - [29/Nov/2016:00:58:43 +0800] \\\"GET /poweredby.png HTTP/1.1\\\" 304 0 \\\"http://192.168.50.119/\\\" \\\"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36\\\" \\\"-\\\"\", \"@version\" =&gt; \"1\", \"@timestamp\" =&gt; \"2016-11-28T18:55:49.590Z\", \"path\" =&gt; \"/var/log/nginx/access.log\", \"host\" =&gt; \"localhost.localdomain\", \"type\" =&gt; \"nginx_log\" 6.安装部署Elasticsearch 192.168.50.119 ELK服务器 创建安装用户 12groupadd elkuseradd es -g elk 1234tar -xf elasticsearch-2.2.0.tar.gz -C /usr/local/vim /usr/local/elasticsearch-2.2.0/config/elasticsearch.yml network.host: 192.168.50.119 # 端口绑定ip地址 http.port: 9200 启动 ，这里遇到一个坑：es用户默认是不能用root用户启动的。所以要切到普通用户启动 123chown -R es.elk /usr/local/elasticsearch-2.2.0su - esnohup /usr/local/elasticsearch-2.2.0/bin/elasticsearch &gt;/usr/local/elasticsearch-2.2.0/nohub &amp; 12[root@localhost ELK]# netstat -tunpl | grep 9200tcp 0 0 ::ffff:192.168.50.119:9200 :::* LISTEN 2183/java 123456789101112[root@localhost ELK]# curl http://192.168.50.119:9200 #查看状态&#123; \"name\" : \"Blood Brothers\", \"cluster_name\" : \"elasticsearch\", \"version\" : &#123; \"number\" : \"2.2.0\", \"build_hash\" : \"8ff36d139e16f8720f2947ef62c8167a888992fe\", \"build_timestamp\" : \"2016-01-27T13:32:39Z\", \"build_snapshot\" : false, \"lucene_version\" : \"5.4.1\" &#125;, \"tagline\" : \"You Know, for Search\" 安装kopf和head插件 1234567891011121314151617[root@localhost conf]# cd /usr/local/elasticsearch-2.2.0/bin/[root@localhost bin]# ./plugin install lmenezes/elasticsearch-kopf-&gt; Installing lmenezes/elasticsearch-kopf...Trying https://github.com/lmenezes/elasticsearch-kopf/archive/master.zip ...Downloading ............................................................ DONEVerifying https://github.com/lmenezes/elasticsearch-kopf/archive/master.zip checksums if available ...NOTE: Unable to verify checksum for downloaded plugin (unable to find .sha1 or .md5 file to verify)Installed kopf into /usr/local/elasticsearch-2.2.0/plugins/kopf[root@localhost bin]# ./plugin install mobz/elasticsearch-head-&gt; Installing mobz/elasticsearch-head...Trying https://github.com/mobz/elasticsearch-head/archive/master.zip ...Downloading .........................................................DONENOTE: Unable to verify checksum for downloaded plugin (unable to find .sha1 or .md5 file to verify)Installed head into /usr/local/elasticsearch-2.2.0/plugins/head 7.安装kibana192.168.50.119 ELK服务器安装 12`[root@localhost ELK]# tar -xf kibana-4.4.0-linux-x64.tar.gz -C /usr/local/[root@localhost ELK]# cd /usr/local/kibana-4.4.0-linux-x64/ 配置 1234[root@localhost kibana-4.4.0-linux-x64]# vim config/kibana.ymlelasticsearch.url: \"http://192.168.50.119:9200\"server.port: 5601server.host: \"0.0.0.0\" 启动 1[root@localhost kibana-4.4.0-linux-x64]# nohup /usr/local/kibana-4.4.0-linux-x64/bin/kibana &gt; /usr/local/kibana-4.4.0-linux-x64/nohub.out &amp; 12[root@localhost ELK]# netstat -tunpl | grep 5601tcp 0 0 0.0.0.0:5601 0.0.0.0:* 浏览器访问http://192.168.50.119:5601/ 8.安装logstash-server服务器 192.168.50.120 服务器 安装jdk和logstash 123456tar -zxf jdk-8u45-linux-x64.tar.gz -C /usr/local/vim /etc/profile #设置环境变量export JAVA_HOME=/usr/local/jdk1.8.0_45export PATH=$PATH:$JAVA_HOME/binexport CLASSPATH=.:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:$CLASSPATHsource /etc/profile #使环境变量生效 12tar –zxf logstash-2.4.0.tar.gz -C /usr/local/mkdir /usr/local/logstash-2.4.0/conf 将redis 中的数据发送到elasticsearch中 12345678910111213141516[root@localhost conf]# cat logstash_server.conf input &#123; redis &#123; port =&gt; \"6379\" host =&gt; \"192.168.50.120\" data_type =&gt; \"list\" key =&gt; \"logstash-redis\" type =&gt; \"redis-input\" &#125;&#125;output &#123; elasticsearch &#123; hosts =&gt; \"192.168.50.119\" index =&gt; \"logstash-%&#123;+YYYY.MM.dd&#125;\" &#125;&#125; 9.在Kibanda上创建nginx日志监控视图 下载资料百度云盘地址 http://pan.baidu.com/s/1jHVKRMQ 案列：对nginxaccess日志的采集 logstash 端配置 1234567891011121314151617input &#123; file &#123; path =&gt; [\"/usr/local/nginx/logs/bc.access.log\"] type =&gt; \"nginx_log\" &#125;&#125;output &#123; redis&#123; host =&gt; \"192.168.1.33\" key =&gt; 'logstash-redis' data_type =&gt; 'list' &#125; stdout &#123;codec =&gt; rubydebug &#125;&#125; redis服务器端logstash 1234567891011121314151617input &#123; redis &#123; port =&gt; \"6379\" host =&gt; \"192.168.1.33\" data_type =&gt; \"list\" key =&gt; \"logstash-redis\" type =&gt; \"redis-input\" &#125;&#125;output &#123; elasticsearch &#123; hosts =&gt; \"192.168.1.6\" user =&gt; \"es_admin\" password =&gt; \"123456\" index =&gt; \"logstashqiantwo-%&#123;+YYYY.MM.dd&#125;\" &#125;&#125; 案列对tomcat的日志采集 logstash 端配置 12345678910111213141516171819202122232425262728293031input&#123; file &#123; path =&gt; \"/usr/local/tomcatweixin/logs/catalina.out\" start_position =&gt; \"beginning\" &#125;&#125;filter &#123; grok &#123; match =&gt; [ \"message\", \"%&#123;COMMONAPACHELOG&#125;\" ] &#125; kv &#123; source =&gt; \"request\" field_split =&gt; \"&amp;?\" value_split =&gt; \"=\" &#125; urldecode &#123; all_fields =&gt; true &#125;&#125;output&#123; stdout &#123; codec =&gt; rubydebug &#125; redis&#123; host=&gt;\"192.168.1.33\" port=&gt;6379 data_type=&gt;\"list\" key=&gt;\"logstash:redis\" &#125;&#125; redis服务器端logstash 1234567891011121314151617input &#123; redis &#123; port =&gt; \"6379\" host =&gt; \"192.168.1.33\" data_type =&gt; \"list\" key=&gt;\"logstash:redis\" &#125;&#125;output &#123; elasticsearch &#123; hosts =&gt; [\"192.168.1.6:9200\"] user =&gt; \"es_admin\" password =&gt; \"123456\" index =&gt; \"logstasweixin-%&#123;+YYYY.MM.dd&#125;\" &#125;&#125; 结束","categories":[{"name":"ELK","slug":"ELK","permalink":"/categories/ELK/"}],"tags":[{"name":"语言","slug":"语言","permalink":"/tags/语言/"},{"name":"ELK","slug":"ELK","permalink":"/tags/ELK/"}],"keywords":[{"name":"ELK","slug":"ELK","permalink":"/categories/ELK/"}]},{"title":"Python 流程控制","slug":"Pythondate2","date":"2016-12-09T08:01:50.697Z","updated":"2016-12-09T08:01:50.697Z","comments":true,"path":"2016/12/09/Pythondate2/","link":"","permalink":"/2016/12/09/Pythondate2/","excerpt":"条件语句Python条件语句是通过一条或多条语句的执行结果（True或者False）来决定执行的代码块。可以通过下图来简单了解条件语句的执行过程:","text":"条件语句Python条件语句是通过一条或多条语句的执行结果（True或者False）来决定执行的代码块。可以通过下图来简单了解条件语句的执行过程: Python程序语言指定任何非0和非空（null）值为true，0 或者 null为false。Python 编程中 if 语句用于控制程序的执行，基本形式为： 1234if 判断条件： 执行语句……else： 执行语句…… 其中”判断条件”成立时（非零），则执行后面的语句，而执行内容可以多行，以缩进来区分表示同一范围。else 为可选语句，当需要在条件不成立时执行内容则可以执行相关语句，具体例子如下： 场景一、用户登陆验证 12345678user=raw_input(\"请输入你的用户名:\")if user==\"zhou\": print 'hello',userelse: print '登录失败！' 场景二、猜年龄游戏 在程序里设定好你的年龄，然后启动程序让用户猜测，用户输入后，根据他的输入提示用户输入的是否正确，如果错误，提示是猜大了还是小了 1234567891011temp = 28busd=int(raw_input(\"请输入一个数字\"))if busd ==temp: print '恭喜你%d猜对了！' %busdelif busd&gt;temp: print '你输入的%d数字太大了！' %busdelse: print '你输入的%d数字太小了！' %busd Python for loopPython提供了for循环和while循环（在Python中没有do..while循环）: 最简单的循环10次 123456for i in range(10): print i,0 1 2 3 4 5 6 7 8 9 需求一：还是上面的程序，但是遇到小于5的循环次数就不走了，直接跳入下一次循环 123456for i in range(10): if i&gt;=5: print i, else: continue 需求二：还是上面的程序，但是遇到大于5的循环次数就不走了，直接退出 123456for i in range(10): if i&lt;=5: print i, else: continue while loop有一种循环叫死循环，一经触发，就运行个天荒地老、海枯石烂。 1234count = 0while True: print(\"alexzhou...\",count)count +=1 上面的代码循环100次就退出吧 1234567count = 0while True: print(\"alexzhou...\",count) count +=1 if count==100: print '循环该结束了大兄弟' break 回到上面for 循环的例子，如何实现让用户不断的猜年龄，但只给最多3次机会，再猜不对就退出程序。 123456789101112131415161718192021temp = 28#年龄等于28岁count =0while count&lt;3: age = int(raw_input(\"请输入的年龄：\"))if age==temp: print '恭喜你%d猜对了！' %age break elif age&lt;temp: print '你输入的年龄%d数字太小了！' %age else: print '你输入的年龄%d数字太大了！' %age count +=1else: print '才那么多次傻逼啊'","categories":[{"name":"python","slug":"python","permalink":"/categories/python/"}],"tags":[{"name":"语言","slug":"语言","permalink":"/tags/语言/"},{"name":"python","slug":"python","permalink":"/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"/categories/python/"}]},{"title":"Python 运算符","slug":"Pythonys","date":"2016-12-09T02:59:05.547Z","updated":"2016-12-09T02:59:05.547Z","comments":true,"path":"2016/12/09/Pythonys/","link":"","permalink":"/2016/12/09/Pythonys/","excerpt":"什么是运算符？本章节主要说明Python的运算符。举个简单的例子 4 +5 = 9 。 例子中，4 和 5 被称为操作数，”+” 称为运算符。Python语言支持以下类型的运算符:算术运算符比较（关系）运算符赋值运算符逻辑运算符位运算符成员运算符身份运算符运算符优先级","text":"什么是运算符？本章节主要说明Python的运算符。举个简单的例子 4 +5 = 9 。 例子中，4 和 5 被称为操作数，”+” 称为运算符。Python语言支持以下类型的运算符:算术运算符比较（关系）运算符赋值运算符逻辑运算符位运算符成员运算符身份运算符运算符优先级 算术运算符以下假设变量a为10，变量b为20： 运算符 描述 实例 + 加 - 两个对象相加 a + b 输出结果 30 - 减 - 得到负数或是一个数减去另一个数 a - b 输出结果 -10 * 乘 - 两个数相乘或是返回一个被重复若干次的字符串 a * b 输出结果 200 / 除 - x除以y b / a 输出结果 2 % 取模 - 返回除法的余数 b % a 输出结果 0 ** 幂 - 返回x的y次幂 a**b 为10的20次方 输出结果 100000000000000000000 // 取整除 - 返回商的整数部分 9//2 输出结果 4.0 比较运算符以下假设变量a为10，变量b为20： 运算符 描述 实例 == 等于 - 比较对象是否相等 (a == b) 返回 False != 不等于 - 比较两个对象是否不相等 (a != b) 返回 true &lt;&gt; 不等于 - 比较两个对象是否不相等 (a &lt;&gt; b) 返回 true。这个运算符类似 != &gt; 大于 - 返回x是否大于y (a &gt; b) 返回 False &lt; 小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写 (a &lt; b) 返回 true &gt;= 大于等于 - 返回x是否大于等于y (a &gt;= b) 返回 False &lt;= 小于等于 - 返回x是否小于等于y (a &lt;= b) 返回 true 赋值运算符以下假设变量a为10，变量b为20： 运算符 描述 实例 = 简单的赋值运算符 c = a + b 将 a + b 的运算结果赋值为 c += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c = a 等效于 c = c a /= 除法赋值运算符 c /= a 等效于 c = c / a %= 取模赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c = a 等效于 c = c a //= 取整除赋值运算符 c //= a 等效于 c = c // a 位运算符按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下：下表中变量 a 为 60，b 为 13，二进制格式如下：a = 0011 1100 b = 0000 1101 a&amp;b = 0000 1100 a|b = 0011 1101 a^b = 0011 0001 ~a = 1100 0011 运算符 描述 实例 &amp; 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 (a &amp; b) 输出结果 12 ，二进制解释： 0000 1100 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1 (a b) 输出结果 61 ，二进制解释： 0011 1101 ^ 按位异或运算符：当两对应的二进位相异时，结果为1 (a ^ b) 输出结果 49 ，二进制解释： 0011 0001 ~ 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 (~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式 &lt;&lt; 左移动运算符：运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0 a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000 &gt;&gt; 右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数 a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111 逻辑运算符Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20: 运算符 逻辑表达式 描述 实例 and x and y 布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值 (a and b) 返回 20 or x or y 布尔”或” - 如果 x 是非 0，它返回 x 的值，否则它返回 y 的计算值 (a or b) 返回 10 not not x 布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True not(a and b) 返回 False 成员运算符除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。 运算符 描述 实例 in 如果在指定的序列中找到值返回 True，否则返回 False x 在 y 序列中 , 如果 x 在 y 序列中返回 True not in 如果在指定的序列中没有找到值返回 True，否则返回 False x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True 身份运算符身份运算符用于比较两个对象的存储单元 运算符 描述 实例 is is是判断两个标识符是不是引用自一个对象 x is y, 如果 id(x) 等于 id(y) , is 返回结果 1 is not is not是判断两个标识符是不是引用自不同对象 x is not y, 如果 id(x) 不等于 id(y). is not 返回结果 1 运算符优先级 运算符 描述 ** 指数 (最高优先级) ~ + - 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) * / % // 乘，除，取模和取整除 + - 加法减法 &gt;&gt; &lt;&lt; 右移，左移运算符 &amp; 位 ‘AND’ ^ 位运算符 &lt;= &lt; &gt; &gt;= 比较运算符 &lt;&gt; == != 等于运算符 = %= /= //= -= += *= **= 赋值运算符 is is not 身份运算符 in not in 成员运算符 not or and 逻辑运算符","categories":[{"name":"python","slug":"python","permalink":"/categories/python/"}],"tags":[{"name":"语言","slug":"语言","permalink":"/tags/语言/"},{"name":"python","slug":"python","permalink":"/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"/categories/python/"}]},{"title":"Lambda表达式以及python的内置函数","slug":"Lambda","date":"2016-12-08T07:40:56.606Z","updated":"2016-12-08T07:40:56.606Z","comments":true,"path":"2016/12/08/Lambda/","link":"","permalink":"/2016/12/08/Lambda/","excerpt":"","text":"Lambda表达式12345678temp= lambda x,y:x+yprint temp(4,5)temp= lambda x,y,z:x*y*zprint temp(4,5,2)list(map(lambda x:x*2,range(10))) 注意: Lambda函数是匿名函数，一般结合map 内置函数12345678a=[]print dir() \\\\列出来的是keyprint vars() \\\\列出来的是key - value['__builtins__', '__doc__', '__file__', '__name__', '__package__', 'a']&#123;'a': [], '__builtins__': &lt;module '__builtin__' (built-in)&gt;, '__file__': 'D:/distribute_project_py/shop.py', '__package__': None, '__name__': '__main__', '__doc__': '\\nproduct = &#123;\\n\\n \\'\\xe8\\x8b\\xb9\\xe6\\x9e\\x9c\\xe6\\x89\\x8b\\xe6\\x9c\\xba\\':3000,\\n \\'mackair\\':8000,\\n \\'\\xe7\\x89\\x99\\xe5\\x88\\xb7\\':8,\\n \\'\\xe5\\x85\\x85\\xe7\\x94\\xb5\\xe7\\xba\\xbf\\':80,\\n \\'\\xe9\\x93\\x85\\xe7\\xac\\x94\\':15\\n\\n&#125;\\nmoney =raw_input(\"\\xe8\\xaf\\xb7\\xe5\\x85\\x85\\xe5\\x80\\xbc\\xe9\\x87\\x91\\xe9\\xa2\\x9d:\")\\nprint \\'\\xe5\\x85\\x85\\xe5\\x80\\xbc\\xe6\\x88\\x90\\xe5\\x8a\\x9f\\xe9\\x87\\x91\\xe9\\xa2\\x9d\\xe4\\xb8\\xba %s\\' %money\\nshop=[]\\nprint \"-\"*12 +u\"\\xe5\\x95\\x86\\xe5\\x93\\x81\\xe5\\x88\\x97\\xe8\\xa1\\xa8\" +\"-\"*12\\nfor i in product:\\n\\n print \\'\\xe5\\x90\\x8d\\xe7\\xa7\\xb0:%s----&gt;\\xe4\\xbb\\xb7\\xe6\\xa0\\xbc\\xef\\xbc\\x9a%d\\'%(i,product[i])\\nprint \"-\"*12 +u\"\\xe5\\x95\\x86\\xe5\\x93\\x81\\xe5\\x88\\x97\\xe8\\xa1\\xa8\" +\"-\"*12\\nsheng_money=money\\nwhile True:\\n buy=raw_input(u\"\\xe4\\xbd\\xa0\\xe9\\x9c\\x80\\xe8\\xa6\\x81\\xe8\\xb4\\xad\\xe7\\x89\\xa9\\xe5\\x90\\x97\\xef\\xbc\\x9fy/n\")\\n if buy==\\'y\\':\\n salry=raw_input(u\"\\xe8\\xbe\\x93\\xe5\\x85\\xa5\\xe4\\xbd\\xa0\\xe8\\xa6\\x81\\xe8\\xb4\\xad\\xe4\\xb9\\xb0\\xe7\\x9a\\x84\\xe5\\x95\\x86\\xe5\\x93\\x81:\")\\n if salry in product:\\n temp=int(sheng_money)-int(product[salry])\\n sheng_money=temp\\n if sheng_money&gt;=0:\\n print \\'\\xe6\\x81\\xad\\xe5\\x96\\x9c\\xe4\\xbd\\xa0\\xe8\\xb4\\xad\\xe4\\xb9\\xb0\\xe6\\x88\\x90\\xe5\\x8a\\x9f,\\xe8\\xb4\\xad\\xe4\\xb9\\xb0\\xe7\\x9a\\x84\\xe5\\x95\\x86\\xe5\\x93\\x81\\xef\\xbc\\x9a%s ,\\xe5\\x89\\xa9\\xe4\\xbd\\x99\\xe9\\x87\\x91\\xe9\\xa2\\x9d\\xe4\\xb8\\xba\\xef\\xbc\\x9a%d,\\xe5\\x95\\x86\\xe5\\x93\\x81\\xe4\\xbb\\xb7\\xe6\\xa0\\xbc\\xe4\\xb8\\xba\\xef\\xbc\\x9a%d\\' %(salry,sheng_money,product[salry])\\n else:\\n print \\'\\xe5\\xbd\\x93\\xe5\\x89\\x8d\\xe5\\x89\\xa9\\xe4\\xbd\\x99\\xe9\\x87\\x91\\xe9\\xa2\\x9d\\xef\\xbc\\x9a%d,\\xe5\\x95\\x86\\xe5\\x93\\x81\\xe4\\xbb\\xb7\\xe6\\xa0\\xbc\\xef\\xbc\\x9a%d,\\xe5\\x89\\xa9\\xe4\\xbd\\x99\\xe9\\x87\\x91\\xe9\\xa2\\x9d\\xe4\\xb8\\x8d\\xe8\\xb6\\xb3\\xe8\\xaf\\xb7\\xe5\\x85\\x85\\xe5\\x80\\xbc\\xef\\xbc\\x81\\' %(sheng_money,product[salry])\\n break\\n else:\\n print \\'\\xe6\\xb2\\xa1\\xe6\\x9c\\x89\\xe8\\xaf\\xa5\\xe5\\x95\\x86\\xe5\\x93\\x81%s\\' %salry\\n salry=raw_input(u\"\\xe8\\xaf\\xb7\\xe9\\x87\\x8d\\xe6\\x96\\xb0\\xe8\\xbe\\x93\\xe5\\x85\\xa5:\")\\n else:\\n print \"\\xe6\\xac\\xa2\\xe8\\xbf\\x8e\\xe4\\xb8\\x8b\\xe6\\xac\\xa1\\xe5\\x85\\x89\\xe4\\xb8\\xb4\\xef\\xbc\\x81\"\\n break\\n '&#125;help(vars()) 123print type(a)&lt;type 'list'&gt; 查看一个变量的类型 导入模块 12from file import demoreload(demo)//再次导入模块 id()，内存地址 1234567t1 = 123t2=999print id(t1)print id(t2)6793536 //t1的内存地址44305828 //t2的内存地址 Abs()，取绝对值 123print abs(-9)9 Bool()，判断真假 1234print bool(1) //输出Trueprint bool(0) //输出Falseprint bool(15) //输出Trueprint bool(-1) //输出True divmod(),数字处理函数,实用场景例如：分页 12345print divmod(9,4)print divmod(9,3)(2, 1)(3, 0) cmp( x, y)，比较大小，如果x&gt;y，则返回1，负责返回-1 1234print cmp(4,8)-1print cmp(4,2)1 Max(),返回参数的最大值 123print max([11,33,55,22,9,77,38])77 min(),返回参数的最小值 123print min([11,33,55,22,9,77,38])9 sum(iterable[, start])，用于计算可迭代对iterable的和 123print sum([11,33,55,22,9,77,38])245 Pow(x,y),用于求参数x的多少次方y 123print pow(2,10)1024 Len(),返回字符串的长度，如果是中文，则返回的是字节的长度 1234567print len('alexzhou')8print len('你好')6 all(iterable)，判断可迭代的值里面如果有出现的值为0，则返回的值为false,否则返回True 123456print all([1,2,3,4,7])print all([1,2,3,4,0,1,22])TrueFalse Any(iterable), 判断可迭代的值里面如果值都为0，则返回的值为false,否则返回True 1234567print any([1,2,3,4,7])print any([1,2,3,4,0,1,22])print any([0,0,0,0,0])TrueTrueFalse Chr(),根据参数值ascii，返回对应的字符串 123456789101112print chr(65)print chr(44)print chr(66)print chr(67)print chr(68)A,BCD Ord(),根据参数值，返回对应的ascii的转换（实用于验证码数字字母转换） 123print ord('A')print ord('B')print ord('C') hex()、bin()、oct(),八进制，16进制，2进制之间的转换 1234567print hex(20)print bin(20)print oct(20)0x140b10100024 Enumerate(),添加索引序号，返回值可以根据自定义的序号返回参数 12345678910111213141516shop=['猕猴桃','香蕉','橙子']for i in shop: print ifor team in enumerate(shop,10): print team[0],team[1]猕猴桃香蕉橙子10 猕猴桃11 香蕉12 橙子 format函数格式化字符串，{0}，{1}相当于占位符%s 123s='我 叫 &#123;0&#125;,&#123;1&#125;'print s.format('Alexzhou','xx') apply(),用于执行函数 1234def say(a,b): print a,bapply(say,(\"hello\",\"Alex\")) map()是 Python 内置的高阶函数，它接收一个函数 f 和一个 list，并通过把函数 f 依次作用在 list 的每个元素上，得到一个新的 list 并返回,常常于lambda一起使用 123456print map(lambda x:(x*2)-1,range(1,50))print map(lambda x:x*2,range(51))100以内的奇偶数[1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97][0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100] Filter(),用于过滤条件，过滤 12345678910shop=[11,22,33]def foo(arg): if arg&lt;22: return True else: return Falsetemp=filter(foo,shop)print temp[11] Reduce(),累加，累乘…，必须要接收两个参数 1234shop=[11,22,33]print reduce(lambda x,y:x+y,shop) zip(),拼接列表的列组成一个新的序列 12345x=[1,2,4]y=[4,5]z=[4,5,6]t =[8,9,10]print zip(x,y,z,t) eval(),字符串当做表达式执行 12a= '9+9'print eval(a) 反射通过字符串的形式去导入模块，并以字符串的形式执行函数 123temp = 'mysqlheerp'mode = __import__(temp)mode.cout()","categories":[{"name":"python","slug":"python","permalink":"/categories/python/"}],"tags":[{"name":"语言","slug":"语言","permalink":"/tags/语言/"},{"name":"python","slug":"python","permalink":"/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"/categories/python/"}]},{"title":"zabbix 监控服务--------使用JMX监控tomcat","slug":"zabbixtomcat","date":"2016-12-05T07:57:40.377Z","updated":"2016-12-05T07:57:40.377Z","comments":true,"path":"2016/12/05/zabbixtomcat/","link":"","permalink":"/2016/12/05/zabbixtomcat/","excerpt":"工作原理我的环境是centOS6.5.64位比如：当Zabbix-Server需要知道java应用程序的某项性能的时候，会启动自身的一个Zabbix-JavaPollers进程去连接Zabbix-JavaGateway请求数据，而ZabbixJavagateway收到请求后使用“JMXmanagementAPI”去查询特定的应用程序，而前提是应用程序这端在开启时需要“-Dcom.sun.management.jmxremote”参数来开启JMX远程查询就行。Java程序会启动自身的一个简单的小程序端口12345向Zabbix-JavaGateway提供请求数据。","text":"工作原理我的环境是centOS6.5.64位比如：当Zabbix-Server需要知道java应用程序的某项性能的时候，会启动自身的一个Zabbix-JavaPollers进程去连接Zabbix-JavaGateway请求数据，而ZabbixJavagateway收到请求后使用“JMXmanagementAPI”去查询特定的应用程序，而前提是应用程序这端在开启时需要“-Dcom.sun.management.jmxremote”参数来开启JMX远程查询就行。Java程序会启动自身的一个简单的小程序端口12345向Zabbix-JavaGateway提供请求数据。 开始监控部署从上面的原理图中我们可以看出，配置Zabbix监控Java应用程序的关键点在于：配置Zabbix-JavaGateway、让Zabbix-Server能够连接Zabbix-JavaGateway、Tomcat开启JVM远程监控功能等 环境说明安装方法:yum安装Zabbix版本: Zabbix-2.4.8JDK版本: jdk1.7.0_71zabbix-server操作系统: CentOS 6.5 X86_64zabbix-agent操作系统: CentOS 6.5 X86_64tomcat:7.0 zabbix的安装这里不做介绍了。 服务端zabbix-server端安装JDK1.rpm安装jdk1rpm -ivh jdk-7u71-linux-x64.rpm 2.添加jdk的环境变量、查看设置是否成功 123456789vi /etc/profileJAVA_HOME=/usr/java/jdk1.8.0_20PATH=$PATH:$JAVA_HOMECLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport JAVA_HOMEexport PATHexport CLASSPATHsource /etc/profilejava -version 安装zabbix-java-gateway1.编译安装1234这里有编译安装跟yum安装方式，我这里采用的是yum的方式安装 yum install zabbix-java-gateway systemctl start zabbix-java-gateway netstat-lntup|grep10052 2.修改zabbix-java-gateway配置文件 1234vim /etc/zabbix/zabbix_java_gateway.confLISTEN_IP=\"0.0.0.0\" 指定bind的地址,默认值为0.0.0.0LISTEN_PORT=10052 指定bind的端口,默认值为10052START_POLLERS=5 指定启动多少进程, 默认为5 3.重启zabbix-java-gateway服务 1/etc/init.d/zabbix-java-gateway restart 4.修改zabbix_server添加以下文件内容 vim /etc/zabbix/zabbix_server.conf JavaGateway=127.0.0.1 指定Zabbix Java GateWay地址 JavaGatewayPort=10052 指定Zabbix Java GateWay端口，默认为10052 StartJavaPollers=5 指定启动时启动的Java Pollers数量 注意：Zabbix Server/Proxy中的StartJavaPollers要小于等于Zabbix Java GateWay配置文件中的START_POLLERS 5.重启zabbix_server服务 /etc/init.d/zabbix-server restart 6.验证是否启动成功 ss -tunlp|grep 10052 tcp LISTEN 0 50 *:10052 *:* users:((&quot;java&quot;,10175,12)) zabbix-agentd端 cd /usr/local/tomcatweixin/bin/1.修改tomcat catalina.sh CATALINA_OPTS=&quot;$CATALINA_OPTS -Dcom.sun.management.jmxremote #开启远程监控 -Dcom.sun.management.jmxremote.port=12345 #远程监控端口 -Dcom.sun.management.jmxremote.ssl=false #远程ssl验证为false -Dcom.sun.management.jmxremote.authenticate=false #关闭权限认证 -Djava.rmi.server.hostname=填写相应主机客户端的IP&quot; #部署了tomcat的主机地址 2.下载catalina-jmx-remote.jar，并且放入 cd /usr/local/tomcatweixin/lib/ 链接：https://pan.baidu.com/s/1kV4ot5H 密码：mzb3 3.重启tomcat /usr/local/tomcatweixin/bin/shutdown.sh /usr/local/tomcatweixin/bin/startup.sh 4.验证是否启动jmx监听成功 lsof -i :12345 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME java 2530 root 16u IPv4 96921409 0t0 TCP *:italk (LISTEN) 5.导入cmdline-jmxclient-0.10.3.jar包在zabbix-server进行测试 java -jar cmdline-jmxclient-0.10.3.jar - 192.168.3.18:12346 java.lang:type=Memory NonHeapMemoryUsage 12/05/2016 15:31:16 +0800 org.archive.jmx.Client NonHeapMemoryUsage: committed: 54853632 init: 24576000 max: 136314880 used: 54294528 表示连接成功 配置zabbix监控页面端1.导入监控模板，可以自定义模板，也可以使用zabbix自带的模板，这里我使用的是自定义模板 点击improt导入 选择文件导入，点击improt 点击hostz主机，选择对应的主机JMX interfaces，填写IP ，客户端端口12345 选择模板，选择之前导入的模板，add,然后保存即可，update 2.过几分钟，等待一会去查看最新数据图形。","categories":[{"name":"zabbix","slug":"zabbix","permalink":"/categories/zabbix/"}],"tags":[{"name":"监控","slug":"监控","permalink":"/tags/监控/"},{"name":"zabbix","slug":"zabbix","permalink":"/tags/zabbix/"}],"keywords":[{"name":"zabbix","slug":"zabbix","permalink":"/categories/zabbix/"}]},{"title":"zabbix如何实现微信报警","slug":"zabbixwechat","date":"2016-12-01T04:19:10.789Z","updated":"2016-12-01T04:19:10.789Z","comments":true,"path":"2016/12/01/zabbixwechat/","link":"","permalink":"/2016/12/01/zabbixwechat/","excerpt":"","text":"申请企业号首先需要申请一个企业号，其实公众号也可以，不过脚本不一样。而且公众号任何人都可以关注，有泄密的风险。企业号只有指定的人可以关注，安全性较高。申请企业号，需要一个绑定你本人开户银行卡的微信号。申请网址https://qy.weixin.qq.com/点击“立即注册”。根据提示注册企业号，到“选择类型”时，选择最右边的企业号。 “主体类型”中选择“团队”。注意：企业描述中：“报警”是敏感词不能使用。 设置企业号如果一切顺利，申请成功并登录企业号，进入如下界面： （没有头像的话，去“设置”里自己传一个）进入“通讯录”，点击“组织架构”旁边的加号，点击“新增成员” 填写完成后点击“保存”，如果一切顺利则应该可以看到用户。 注：这里的账号相当于你的企业账号，与微信号无关。必须先在此处创建用户，并且填写正确的微信号或者手机号，才可通过扫描二维码关注该企业号（知道为何安全了吧）。 关注企业号的方法点击左侧的“设置”-二维码，使用微信扫一扫扫描二维码。 点击左侧列的“应用中心”，点击“我的应用”下面的加号。填写应用名称，描述。一切正常的话，点击进入刚才创建的应用。 这里要记住一个值：应用ID。 设置管理员：设置-功能设置-权限管理-新建管理组,设置权限中，保证管理员可以读取访问通讯录，可以发消息。添加管理员之后，屏幕上显示二维码，用你的微信扫一扫扫描二维码并且设置登录密码。 注意：这里要记录下来下面的CorpID和Secret。现在万事俱备，可以开始编写脚本了。 编写脚本检查/usr/etc/zabbix/zabbix_server.conf 中，加入 AlertScriptsPath=/usr/lib/zabbix/alertscripts如果有的话，就确定好报警目录。创建目录。mkdir –p /usr/lib/zabbix/alertscripts在目录下创建wechat.sh 脚本文件。 1234567891011121314151617181920212223242526#!/bin/bashCorpID=&lt;刚才记下来的CorpID，不要包含尖括号&gt;Secret=&lt;刚才记下来的Secret，不要包含尖括号&gt;GURL=\"https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid=$CorpID&amp;corpsecret=$Secret\"Gtoken=$(/usr/bin/curl -s -G $GURL | awk -F\\\" '&#123;print $4&#125;')PURL=\"https://qyapi.weixin.qq.com/cgi-bin/message/send?access_token=$Gtoken\"function body() &#123; local int AppID=&lt;刚才记下来的应用id，不要包含尖括号&gt; local UserID=$1 local PartyID=1 local Msg=$(echo \"$@\" | cut -d\" \" -f3-) printf '&#123;\\n' printf '\\t\"touser\": \"'\"$User\"\\\"\",\\n\" printf '\\t\"toparty\": \"'\"$PartyID\"\\\"\",\\n\" printf '\\t\"msgtype\": \"text\",\\n' printf '\\t\"agentid\": \"'\" $AppID \"\\\"\",\\n\" printf '\\t\"text\": &#123;\\n' printf '\\t\\t\"content\": \"'\"$Msg\"\\\"\"\\n\" printf '\\t&#125;,\\n' printf '\\t\"safe\":\"0\"\\n' printf '&#125;\\n'&#125;/usr/bin/curl --data-ascii \"$(body $1 $2 $3)\" $PURL 将上面文字部分替换成自己记录下来的值。保存退出 12chown –R zabbix:zabbix /usr/lib/zabbix/alertscriptschmod 750/usr/lib/zabbix/alertscripts/wechat.sh 执行./wechat.sh 1 1 test 看自己微信是否能收到东西。如果能的话，继续下一步。反之检查上面有什么问题。 添加触发器 点击管理(Administration)-媒体类型(Media types)-创建媒体类型(Create media type) 类型（Type）中选择脚本（Script），脚本名称（Script name）里填写wechat.sh点击旁边的用户(User)创建一个用户。 在Media中点击Add When active中按如图填写，默认为7*24小时Use if severity选择通告何种等级的消息，从上往下分别是：未分类，资讯，警告，一般，高威胁，灾难。Send to 填写你的微信号。点击Add. 下一步，点击许可权（Permissions），将用户类型（User type）改为Zabbix超级用户（Zabbix Super Admin）。创建触发动作。 如此填写： Host:{HOST.NAME}Time:{EVENT.DATE} {EVENT.TIME}Status:{TRIGGER.STATUS}Event:{TRIGGER.NAME} 勾选下面的故障恢复信息(Recovery message)并在Recovery message中填写：Server recovered.Host:{HOST.NAME}Time:{EVENT.DATE} {EVENT.TIME}Status:{TRIGGER.STATUS}Event:{TRIGGER.NAME} 这样当服务器恢复后，可以收到一条以Server recovered开头的信息，省去了大半夜打车跑公司之苦。条件(Conditions)无视。 点击Operations，点击New 点击User中的Add. 点击刚才创建的用户。 最后结果如图，点击Add。然后点击最下面的Add.配置完毕，现在关闭被监控机。[root@Jewel ~]# service network stop等一会，若微信收到消息，则配置成功。 反之检查Zabbix报警是否有问题。至此监控报警已经配置完成。","categories":[{"name":"zabbix","slug":"zabbix","permalink":"/categories/zabbix/"}],"tags":[{"name":"监控","slug":"监控","permalink":"/tags/监控/"},{"name":"zabbix","slug":"zabbix","permalink":"/tags/zabbix/"}],"keywords":[{"name":"zabbix","slug":"zabbix","permalink":"/categories/zabbix/"}]},{"title":"python的字符串续及列表","slug":"list","date":"2016-11-13T07:37:53.250Z","updated":"2016-11-13T07:37:53.247Z","comments":true,"path":"2016/11/13/list/","link":"","permalink":"/2016/11/13/list/","excerpt":"index(self, sub, start=None, end=None):str –&gt; 指定检索的字符串beg –&gt; 开始索引，默认为0。end –&gt; 结束索引，默认为字符串的长度。检测字符串中是否包含子字符串 str ，如果指定 beg（开始） 和 end（结束） 范围，则检查是否包含在指定范围内，该方法与 python find()方法一样，只不过如果str不在 string中会报一个异常。","text":"index(self, sub, start=None, end=None):str –&gt; 指定检索的字符串beg –&gt; 开始索引，默认为0。end –&gt; 结束索引，默认为字符串的长度。检测字符串中是否包含子字符串 str ，如果指定 beg（开始） 和 end（结束） 范围，则检查是否包含在指定范围内，该方法与 python find()方法一样，只不过如果str不在 string中会报一个异常。 123456789&gt;&gt;&gt; string=\"hello word\"# 返回字符串所在的位置&gt;&gt;&gt; string.index(\"o\")4# 如果查找一个不存在的字符串那么就会报错&gt;&gt;&gt; string.index(\"a\")Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;ValueError: substring not found isalnum(self): 法检测字符串是否由字母和数字组成，如果string至少有一个字符并且所有字符都是字母或数字则返回True,否则返回False 12345678&gt;&gt;&gt; string=\"hes2323\"# 如果存在数字或字母就返回`True`，否则返回`False`&gt;&gt;&gt; string.isalnum()True# 中间有空格返回的就是False了&gt;&gt;&gt; string=\"hello word\"&gt;&gt;&gt; string.isalnum()False isalpha(self): 检测字符串是否只由字母组成。 12345678# 如果全部都是字母就返回`True`&gt;&gt;&gt; string=\"helloword\"&gt;&gt;&gt; string.isalpha()True# 否则就返回False&gt;&gt;&gt; string=\"hes2323\"&gt;&gt;&gt; string.isalpha()False isdigit(self):检测字符串是否只由数字组成 1234567# 如果变量里面都是数字就返回`True`，否则就返回`False`&gt;&gt;&gt; string=\"hes2323\"&gt;&gt;&gt; string.isdigit()False&gt;&gt;&gt; string=\"2323\"&gt;&gt;&gt; string.isdigit()True islower(self): 1234567# 如果变量内容全部都是小写字母就返回`True`，否则就返回`False`&gt;&gt;&gt; string=\"hesasdasd\"&gt;&gt;&gt; string.islower()True&gt;&gt;&gt; string=\"HelloWord\"&gt;&gt;&gt; string.islower()False istitle(self):检测字符串中所有的单词拼写首字母是否为大写，且其他字母为小写。 1234567# 如果变量的内容首字母是大写并且其他字母为小写，那么就返回`True`，否则会返回`False`&gt;&gt;&gt; string=\"Hello Word\"&gt;&gt;&gt; string.istitle()True&gt;&gt;&gt; string=\"Hello word\"&gt;&gt;&gt; string.istitle()False isupper(self): 检测字符串中所有的字母是否都为大写。 1234567# 如果变量值中所有的字母都是大写就返回`True`，否则就返回`False`&gt;&gt;&gt; string=\"hello word\"&gt;&gt;&gt; string.isupper()False&gt;&gt;&gt; string=\"HELLO WORD\"&gt;&gt;&gt; string.isupper()True join(self, iterable): 将序列中的元素以指定的字符连接生成一个新的字符串。 123&gt;&gt;&gt; string=(\"a\",\"b\",\"c\")&gt;&gt;&gt; '-'.join(string)'a-b-c' lower(self): 转换字符串中所有大写字符为小写。 1234# 把变量里的大写全部转换成小写&gt;&gt;&gt; string=\"Hello WORD\"&gt;&gt;&gt; string.lower()'hello word' lstrip(self, chars=None): 12345&gt;&gt;&gt; string=\"hello word\"&gt;&gt;&gt; string.lstrip(\"hello \")'word'chars –&gt; 指定截取的字符法用于截掉字符串左边的空格或指定字符 replace(self, old, new, count=None): old –&gt; 将被替换的子字符串new –&gt; 新字符串，用于替换old子字符串count–&gt; 可选字符串, 替换不超过count次把字符串中的 old(旧字符串)替换成new(新字符串)，如果指定第三个参数max，则替换不超过max次 1234567string=\"www.ss.me\"# 把就字符串`www.`换成新字符串`https://`&gt;&gt;&gt; string.replace(\"www.\",\"https://\")'https://www.xxx.me'# 就字符串`w`换成新字符串`a`只替换`2`次&gt;&gt;&gt; string.replace(\"w\",\"a\",2)'aaw.ansssss.me' rfind(self, sub, start=None, end=None):查找的字符串beg –&gt; 开始查找的位置，默认为0end –&gt; 结束查找位置，默认为字符串的长度返回字符串最后一次出现的位置，如果没有匹配项则返回-1。 1234567string=\"hello word\"# rfind其实就是反向查找&gt;&gt;&gt; string.rfind(\"o\")7# 指定查找的范围&gt;&gt;&gt; string.rfind(\"o\",0,6)4 rsplit(self, sep=None, maxsplit=None): str--&gt; 分隔符，默认为空格 *num* –&gt; 分割次数从右到左通过指定分隔符对字符串进行切片,如果参数num有指定值，则仅分隔num个子字符串 12345string=\"www.msbgn.cn\"&gt;&gt;&gt; string.rsplit(\".\",1)['www.msbgn', 'cn']&gt;&gt;&gt; string.rsplit(\".\",2)['www', 'msbgn', 'cn'] split(self, sep=None, maxsplit=None): str–&gt; 分隔符，默认为空格 num` –&gt; 分割次数从左到右通过指定分隔符对字符串进行切片,如果参数num有指定值，则仅分隔num个子字符串 1234567string=\"www.msbgn.cn\"# 指定切一次，以`.`来分割&gt;&gt;&gt; string.split(\".\",1)['www', 'msbgn.cn']# 指定切二次，以`.`来分割&gt;&gt;&gt; string.split(\".\",2)['www', 'msbgn', 'cn'] splitlines(self, keepends=False): num –&gt; 分割行的次数按照行分隔，返回一个包含各行作为元素的列表，如果num指定则仅切片num个行. 12345678910# 定义一个有换行的变量，`\\n`可以划行&gt;&gt;&gt; string=\"www\\msbgn\\cn\"# 输出内容&gt;&gt;&gt; print(string)wwwmsbgncn# 把有行的转换成一个列表&gt;&gt;&gt; string.splitlines(1)['www\\n', 'msbgn\\n', 'cn'] strip(self, chars=None): chars –&gt; 移除字符串头尾指定的字符移除字符串头尾指定的字符（默认为空格） 12345678910&gt;&gt;&gt; string=\" www.msbgn.cn\"&gt;&gt;&gt; string' www.msbgn.cn'# 删除空格&gt;&gt;&gt; string.strip()'www.msbgn.cn'&gt;&gt;&gt; string=\"_www.msbgn.cn_\"# 指定要把左右两边的\"_\"删除掉&gt;&gt;&gt; string.strip(\"_\")'www.msbgn.cn' swapcase(self): 用于对字符串的大小写字母进行转换，大写变小写，小写变大写 123&gt;&gt;&gt; string=\"hello WORD\"&gt;&gt;&gt; string.swapcase()'HELLO word' translate(self, table, deletechars=None): able –&gt; 翻译表，翻译表是通过maketrans方法转换而来deletechars –&gt; 字符串中要过滤的字符列表 根据参数table给出的表(包含 256 个字符)转换字符串的字符, 要过滤掉的字符放到 del 参数中。 upper(self): 将字符串中的小写字母转为大写字母 123string=\"hello word\"&gt;&gt;&gt; string.upper()'HELLO WORD' 列表(list)定义列表的两种方法 第一种 1name_list = ['Python', 'PHP', 'JAVA'] 第二种 1name_list ＝ list(['Python', 'PHP', 'JAVA']) 列表所具备的方法 append(self, p_object): 在列表末尾添加新的对象 1234name_list = ['zhou','jack','old gog']name_list.append('sds')&gt;&gt;&gt; name_list['zhou', 'jack', 'old gog', 'sds'] count(self, value): bj –&gt; 列表中统计的对象统计某个元素在列表中出现的次数 12name_list.count('jack')2 insert(self, index, p_object): index –&gt; 对象obj需要插入的索引位置obj –&gt; 要出入列表中的对象将指定对象插入列表 123name_list.insert(2,'110')&gt;&gt;&gt; name_list['zhou', 'jack', '110', 'old gog', 'sds'] remove(self, value): value –&gt; 列表中要移除的对象移除列表中某个值的第一个匹配项 123name_list.remove('old gog')&gt;&gt;&gt; name_list['zhou', 'jack', '110', 'sds'] extend(self, iterable): seq –&gt; 元素列表用于在列表末尾一次性追加另一个序列中的多个值 1234567891011name_list = ['Python', 'PHP', 'Python']&gt;&gt;&gt; name_OS = ['Windows', 'Linux', 'Unix']&gt;&gt;&gt; name_list['Python', 'PHP', 'Python']&gt;&gt;&gt; name_OS['Windows', 'Linux', 'Unix']# 把列表`name_OS`中的内容添加到`name_list`的尾部&gt;&gt;&gt; name_list.extend(name_OS)# 输出的结果&gt;&gt;&gt; name_list['Python', 'PHP', 'Python', 'Windows', 'Linux', 'Unix'] pop(self, index=None): index –&gt; 可选参数，要移除列表元素的位置移除列表中的一个元素，并且返回该元素的值 123456&gt;&gt;&gt; name_list = ['Python', 'PHP', 'JAVA']# 删除位置1上面的内容，并且返回删除的字符串&gt;&gt;&gt; name_list.pop(1)'PHP'&gt;&gt;&gt; name_list['Python', 'JAVA'] sort(self, cmp=None, key=None, reverse=False): 对原列表进行排序，如果指定参数，则使用比较函数指定的比较函数 123456&gt;&gt;&gt; name_list = ['Python', 'PHP', 'JAVA']&gt;&gt;&gt; name_list['Python', 'PHP', 'JAVA']&gt;&gt;&gt; name_list.sort()&gt;&gt;&gt; name_list['JAVA', 'PHP', 'Python'] 列表求奇偶以及练习 隔断截取，求奇偶 1234567891011name_list[1::2]['jack', 2, 4]&gt;&gt;&gt; name_list[1::3]['jack', 3]&gt;&gt;&gt; a = range(100)&gt;&gt;&gt; a[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]&gt;&gt;&gt; a[::2][0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98]&gt;&gt;&gt; a[1::2][1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99] 练习 求列表中2出现的次数的，分别对应的位置 1234567name_list = [2,'zhou','jack',3,'old gog',1,2,3,4,5,6,2,8,99,3,2,666,2]a1 = 0for i in range(name_list.count(2)): nexts =name_list[a1:] a2 = nexts.index(2)+1 print 'find:',a1 + nexts.index(2) a1+=a2 结束","categories":[{"name":"python","slug":"python","permalink":"/categories/python/"}],"tags":[{"name":"语言","slug":"语言","permalink":"/tags/语言/"},{"name":"python","slug":"python","permalink":"/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"/categories/python/"}]},{"title":"Python的数据类型和运算","slug":"Python003","date":"2016-11-10T04:11:22.920Z","updated":"2016-11-10T04:11:22.920Z","comments":true,"path":"2016/11/10/Python003/","link":"","permalink":"/2016/11/10/Python003/","excerpt":"语法要求 缩进统一变量 标识符第一个字符必须是字母表中的字母（大写或者小写）或者一个下划线(‘_’) 标识符名称的组成部分可以由字母(大写或小写)、下划线（’_’）或数字0-9组成 标识符名称是对大小写敏感的，列如，myname和Myname不是一个标识符。注意前者中的小写m和后者中的大写M. 有效标识符名称的列子有 i、_my_name、name_32和alb2_c3。 无效的标识符名称的列子有 2thongs、this is spaced out和my-name.","text":"语法要求 缩进统一变量 标识符第一个字符必须是字母表中的字母（大写或者小写）或者一个下划线(‘_’) 标识符名称的组成部分可以由字母(大写或小写)、下划线（’_’）或数字0-9组成 标识符名称是对大小写敏感的，列如，myname和Myname不是一个标识符。注意前者中的小写m和后者中的大写M. 有效标识符名称的列子有 i、_my_name、name_32和alb2_c3。 无效的标识符名称的列子有 2thongs、this is spaced out和my-name. 定义变量123task_detail=1（变量写法一）TaskDetail=1 （变量写法二）taskDetail=1 （驼峰写法） 数据类型(特征划分)数字类型 布尔型（bool）判断真假123456789falsetrueif False:print 'ddd'...if True: print 'dddd'...ddd 整型在Python2里，一个int型包含32位，可以存储从-2147483648到214483647的整数一个long型会占用更多的空间，64为可以存储-922372036854775808到922372036854775808的整数python3里long型已经不存在了，而int型可以存储到任意大小的整型，甚至超过64为。Python内部对整数的处理分为普通整数和长整数，普通整数长度为机器位长，通常都是32位，超过这个范围的整数就自动当长整数处理，而长整数的范围几乎完全没限制，如下： 123456789a = 2**64a18446744073709551616L&gt;&gt;&gt; type(a)&lt;type 'long'&gt;a = 2**12&gt;&gt;&gt; a = 2**12&gt;&gt;&gt; type(a)&lt;type 'int'&gt; 非整型列如：浮点型,序列类型,字符串，列表，元组,字典 123456789101112131415161718&gt;&gt;&gt; type(3.14)&lt;type 'float'&gt;name='alex'type(name)&lt;type 'str'&gt;&gt;&gt;&gt; if type(name) is str: print 'ddd'... dddname_list=['sdss','alexzhou','zhoualx']&gt;&gt;&gt; type(name_list)&lt;type 'list'&gt;name=&#123;'alexzhou':[28,'IT']&#125;name['alexzhou'][28,'IT']&lt;type 'dict'&gt; 数学运算12345671+1*3/22**32A=14B=12A&gt;B,A&lt;=B,A!=B 字符串(str)字符串类型是python的序列类型，他的本质就是字符序列，而且python的字符串类型是不可以改变的，你无法将原字符串进行修改，但是可以将字符串的一部分复制到新的字符串中，来达到相同的修改效果。 使用引号创建字符串创建字符串类型可以使用单引号或者双引号又或者三引号来创建，实例如下 单引号 1234&gt;&gt;&gt; string = 'alxe'# type是查看一个变量的数据类型&gt;&gt;&gt; type(string)&lt;class 'str'&gt; 双引号 1234&gt;&gt;&gt; string = \"alxe\"# type是查看一个变量的数据类型&gt;&gt;&gt; type(string) &lt;class 'str'&gt; 三引号 123&gt;&gt;&gt; string = \"\"\"alxe\"\"\"&gt;&gt;&gt; type(string)&lt;class 'str'&gt; 字符串所具备的方法 capitalize(self): 把值得首字母变大写 123&gt;&gt;&gt; name=\"alxe\"&gt;&gt;&gt; name.capitalize()'alxe' center(self, width, fillchar=None):内容居中，width：字符串的总宽度；fillchar：填充字符，默认填充字符为空格。 1234567891011121314# 定义一个字符串变量，名为\"string\"，内容为\"hello word\"&gt;&gt;&gt; string=\"hello word\"# 输出这个字符串的长度，用len(value_name)&gt;&gt;&gt; len(string)10# 字符串的总宽度为10，填充的字符为\"*\"&gt;&gt;&gt; string.center(10,\"*\")'hello word'# 如果设置字符串的总产都为11，那么减去字符串长度10还剩下一个位置，这个位置就会被*所占用&gt;&gt;&gt; string.center(11,\"*\")'*hello word'# 是从左到右开始填充&gt;&gt;&gt; string.center(12,\"*\")'*hello word*' count(self, sub, start=None, end=None): sub –&gt; 搜索的子字符串start –&gt; 字符串开始搜索的位置。默认为第一个字符,第一个字符索引值为0。end –&gt; 字符串中结束搜索的位置。字符中第一个字符的索引为 0。默认为字符串的最后一个位置。 用于统计字符串里某个字符出现的次数,可选参数为在字符串搜索的开始与结束位置。 1234567&gt;&gt;&gt; string=\"hello word\"# 默认搜索出来的\"l\"是出现过两次的&gt;&gt;&gt; string.count(\"l\")2# 如果指定从第三个位置开始搜索，搜索到第六个位置，\"l\"则出现过一次&gt;&gt;&gt; string.count(\"l\",3,6)1 decode(self, encoding=None, errors=None):解码 1234# 定义一个变量内容为中文temp = \"中文\"# 把变量的字符集转化为UTF-8temp_unicode = temp.decode(\"utf-8\") encode(self, encoding=None, errors=None):编码，针对unicode 1234# 定义一个变量内容为中文,字符集为UTF-8temp = u\"中文\"# 编码，需要指定要转换成什么编码temp_gbk = temp_unicode.encode(\"gbk\") endswith(self, suffix, start=None, end=None): suffix –&gt; 后缀，可能是一个字符串，或者也可能是寻找后缀的tuple。start –&gt; 开始，切片从这里开始。end –&gt; 结束，片到此为止。 于判断字符串是否以指定后缀结尾，如果以指定后缀结尾返回True，否则返回False。 12345678910&gt;&gt;&gt; string=\"hello word\"# 判断字符串中是否已\"d\"结尾，如果是则返回\"True\"&gt;&gt;&gt; string.endswith(\"d\")True# 判断字符串中是否已\"t\"结尾，不是则返回\"False\"&gt;&gt;&gt; string.endswith(\"t\")False# 制定搜索的位置，实则就是从字符串位置1到7来进行判断，如果第七个位置是\"d\"，则返回True，否则返回False&gt;&gt;&gt; string.endswith(\"d\",1,7)False expandtabs(self, tabsize=None): tabsize –&gt; 指定转换字符串中的 tab 符号(‘\\t’)转为空格的字符数。把字符串中的tab符号(‘\\t’)转为空格，tab符号(‘\\t’)默认的空格数是8。 12345678910&gt;&gt;&gt; string=\"hello word\"# 输出变量\"string\"内容的时候会发现中间有一个\"\\t\"，这个其实就是一个`tab`键&gt;&gt;&gt; string'hello\\tword'# 把`tab`键换成一个空格&gt;&gt;&gt; string.expandtabs(1)'hello word'# 把`tab`键换成十个空格&gt;&gt;&gt; string.expandtabs(10)'hello word' find(self, sub, start=None, end=None): str –&gt; 指定检索的字符串beg –&gt; 开始索引，默认为0。end –&gt; 结束索引，默认为字符串的长度。 检测字符串中是否包含子字符串str，如果指定beg(开始)和end(结束)范围，则检查是否包含在指定范围内，如果包含子字符串返回开始的索引值，否则返回-1。 1234567&gt;&gt;&gt; string=\"hello word\"# 返回`o`在当前字符串中的位置，如果找到第一个`o`之后就不会再继续往下面寻找了&gt;&gt;&gt; string.find(\"o\")4# 从第五个位置开始搜索，返回`o`所在的位置&gt;&gt;&gt; string.find(\"o\",5)7 format(args, *kwargs): 未完，待续…..","categories":[{"name":"Python","slug":"Python","permalink":"/categories/Python/"}],"tags":[{"name":"语言","slug":"语言","permalink":"/tags/语言/"},{"name":"Python","slug":"Python","permalink":"/tags/Python/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"/categories/Python/"}]},{"title":"Haporxy+Keepalived 配置与安装","slug":"Haporxy+Keepalived","date":"2016-11-09T04:18:50.687Z","updated":"2016-11-09T04:18:50.687Z","comments":true,"path":"2016/11/09/Haporxy+Keepalived/","link":"","permalink":"/2016/11/09/Haporxy+Keepalived/","excerpt":"简介 软件负载均衡一般通过两种方式来实现：基于操作系统的软负载实现和基于第三方应用的软负载实现。LVS就是基于Linux操作系统实现的一种软负载，HAProxy就是开源的并且基于第三应用实现的软负载。 HAProxy相比LVS的使用要简单很多，功能方面也很丰富。当 前，HAProxy支持两种主要的代理模式:”tcp”也即4层（大多用于邮件服务器、内部协议通信服务器等），和7层（HTTP）。在4层模式 下，HAProxy仅在客户端和服务器之间转发双向流量。7层模式下，HAProxy会分析协议，并且能通过允许、拒绝、交换、增加、修改或者删除请求 (request)或者回应(response)里指定内容来控制协议，这种操作要基于特定规则。 拓扑图","text":"简介 软件负载均衡一般通过两种方式来实现：基于操作系统的软负载实现和基于第三方应用的软负载实现。LVS就是基于Linux操作系统实现的一种软负载，HAProxy就是开源的并且基于第三应用实现的软负载。 HAProxy相比LVS的使用要简单很多，功能方面也很丰富。当 前，HAProxy支持两种主要的代理模式:”tcp”也即4层（大多用于邮件服务器、内部协议通信服务器等），和7层（HTTP）。在4层模式 下，HAProxy仅在客户端和服务器之间转发双向流量。7层模式下，HAProxy会分析协议，并且能通过允许、拒绝、交换、增加、修改或者删除请求 (request)或者回应(response)里指定内容来控制协议，这种操作要基于特定规则。 拓扑图 正文1. node1配置1.1 安装keepalived+Haporxy123[root@node1 ~]# systemctl stop firewalld.service [root@node1 ~]# systemctl disable firewalld.service [root@node1 ~]# setsebool -P haproxy_connect_any on 这里最好禁用seliunx，我这边是因为selinux出问题，修改配置文件无效。 1[root@node1 ~]# yum install psmisc.x86_64 haproxy.x86_64 keepalived.x86_64 注: 因为需要使用killall命令，所以额外安装了psmisc包 配置keepalived 1[root@node1 ~]# vim /etc/keepalived/keepalived.conf 改为 1234567891011121314151617181920212223242526272829303132333435363738394041424344! Configuration File for keepalivedglobal_defs &#123; notification_email &#123; leekexi@gmail.com #可以多个地址 &#125; notification_email_from leekexi@gmail.com smtp_server smtp.gmail.com smtp_connect_timeout 30 router_id LVS_MASTER &#125;vrrp_script checkhaproxy &#123; script \"killall -0 haproxy\" interval 3 weight -20 &#125;vrrp_instance VI_1 &#123; interface eno16777728 state MASTER virtual_router_id 50 priority 101 advert_int 1 nopreempt debug authentication &#123; auth_type PASS auth_pass 1111 &#125; virtual_ipaddress &#123; 10.199.200.10/24 &#125; track_script &#123; chk_haproxy &#125; notify_master \"/etc/keepalived/scripts/notify.sh master 172.16.10.201\" notify_backup \"/etc/keepalived/scripts/notify.sh backup 172.16.10.201\" notify_fault \"/etc/keepalived/scripts/notify.sh fault 172.16.10.201\" notify_stop \"/etc/keepalived/scripts/notify.sh stop 172.16.10.201\"&#125; 配置相关脚本 1[root@node2 ~]# vim /etc/keepalived/scripts/notify.sh 写入 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#!/bin/bash# Author: Jason.Yu &lt;admin@lnmmp.com&gt;# description: An example of notify script##contact='root@localhost'#notify() &#123;#mailsubject=\"`hostname` to be $1: $2 floating\"#mailbody=\"`date '+%F %H:%M:%S'`: vrrp transition, `hostname` changed to be $1\"#echo$mailbody | mail -s \"$mailsubject\"$contact#&#125;case \"$1\" in master)# notify master $2 echo \"`date +%c` success to get Vip,start-up haproxy.\" &gt;&gt; /etc/keepalived/scripts/master.log systemctl restart haproxy.service exit 0 ;; backup)# notify backup $2 # 在节点切换成backup状态时，无需刻意停止haproxy服务，防止chk_maintaince和chk_haproxy多次对haproxy服务操作； echo \"`date +%c` host \"$2\" is backup. \" &gt;&gt; /etc/keepalived/scripts/backup.log exit 0 ;; fault)# notify fault $2# 同上 kepid=`pidof keepalived` if [ $kepid == \"\" ] then echo \"`date +%c` no keepalived process id\" &gt;&gt; /etc/keepalived/scripts/fault.log else echo \"`date +%c` will stop keepalived \" &gt;&gt; /etc/keepalived/scripts/fault.log systemctl stop keepalived.service fi exit 0 ;; stop) pid=`pidof haproxy` echo \"`date +%c` stop host \"$2\" is haproxy\" &gt;&gt; /etc/keepalived/scripts/stop.log kill -9 $pid ;; * ) echo'Usage: `basename $0` &#123;master|backup|fault&#125;' exit 1 ;; esac### 2. 安装kibana 1.2 配置haproxy 1[root@node1 ~]# vim /etc/haproxy/haproxy.cfg 改为 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273global # to have these messages end up in /var/log/haproxy.log you will # need to: # # 1) configure syslog to accept network log events. This is done # by adding the '-r' option to the SYSLOGD_OPTIONS in # /etc/sysconfig/syslog # # 2) configure local2 events to go to the /var/log/haproxy.log # file. A line like the following can be added to # /etc/sysconfig/syslog # # local2.* /var/log/haproxy.log # log 127.0.0.1 local2 chroot /var/lib/haproxy #修改haproxy的工作目录至指定的目录并在放弃权限之前执行chroot()操作。 pidfile /var/run/haproxy.pid maxconn 4000 #设定每个haproxy进程所接受的最大并发连接数。 user haproxy group haproxy daemon #让haproxy以守护进程的方式工作于后台。 # turn on stats unix socket stats socket /var/lib/haproxy/stats#---------------------------------------------------------------------# common defaults that all the 'listen' and 'backend' sections will# use if not designated in their block#---------------------------------------------------------------------defaults mode http #设定实例的运行模式或协议。 log global #为每个实例启用事件和流量日志，因此可用于所有区段。 option httplog option dontlognull option http-server-close option forwardfor except 127.0.0.1/8 如果服务器上的应用程序想记录发起请求的客户端的IP地址，需要在HAProxy上配置此选项，这样HAProxy会把客户端的IP信息发送给服务器，在HTTP请求中添加\"X-Forwarded-For\"字段。 option redispatch #当serverId对应的服务器挂掉后，强制定向到其他健康的服务器 retries 3 timeout http-request 10s timeout queue 1m timeout connect 10s timeout client 1m timeout server 1m timeout http-keep-alive 10s timeout check 10s #心跳检测超时 maxconn 3000listen stats mode http bind 0.0.0.0:1080 stats enable stats hide-version stats uri /haproxyadmin?stats stats realm Haproxy\\ Statistics stats auth admin:admin stats admin if TRUEfrontend http-in #指定前端服务 bind *:80 #指定监听端口 mode http log global option httpclose option logasap option dontlognull capture request header Host len 20 capture request header Referer len 60 default_backend serversbackend servers balance roundrobin #使用roundrobin算法 server websrv1 172.16.10.203:80 check maxconn 2000 server websrv2 172.16.10.204:80 check maxconn 2000 测试 12[root@node1 ~]# haproxy -c -f /etc/haproxy/haproxy.cfg 1.3 配置日志 1[root@node1 ~]# vim /etc/rsyslog.conf 增加一条 1local2.* /var/log/haproxy.log 修改日志等级 1[root@node1 ~]# vim /etc/sysconfig/rsyslog 改为 12345# Options for rsyslogd# Syslogd options are deprecated since rsyslog v3.# If you want to use them, switch to compatibility mode 2 by \"-c 2\"# See rsyslogd(8) for more detailsSYSLOGD_OPTIONS=\"-c 2 -r\" 2. node2配置2.1 安装keepalived+Haporxy 1234[root@node2 ~]# setsebool -P haproxy_connect_any on#这里最好禁用seliunx，我这边是因为selinux出问题，修改配置文件无效。[root@node2 ~]# systemctl disable firewalld.service [root@node2 ~]# yum install psmisc.x86_64 haproxy.x86_64 keepalived.x86_64 注：因为需要使用killall命令，所以额外安装了psmisc包 配置keepalived 1[root@node2 ~]# vim /etc/keepalived/keepalived.conf 改为 1234567891011121314151617181920212223242526272829303132333435363738394041424344! Configuration File for keepalivedglobal_defs &#123; notification_email &#123; leekexi@gmail.com #可以多个地址 &#125; notification_email_from leekexi@gmail.com smtp_server smtp.gmail.com smtp_connect_timeout 30 router_id LVS_BACKUP &#125;vrrp_script checkhaproxy&#123; script \"killall -0 haproxy\" interval 3 weight -20&#125;vrrp_instance VI_1 &#123; interface eno16777728 state BACKUP virtual_router_id 50 priority 100 advert_int 1 nopreempt debug authentication &#123; auth_type PASS auth_pass 1111 &#125; virtual_ipaddress &#123; 10.199.200.10/24 &#125; track_script &#123; chk_haproxy &#125; notify_master \"/etc/keepalived/scripts/notify.sh master 172.16.10.202\" notify_backup \"/etc/keepalived/scripts/notify.sh backup 172.16.10.202\" notify_fault \"/etc/keepalived/scripts/notify.sh fault 172.16.10.202\" notify_stop \"/etc/keepalived/scripts/notify.sh stop 172.16.10.202\"&#125; 配置相关脚本 1[root@node2 ~]# vim /etc/keepalived/scripts/notify.sh 写入 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#!/bin/bash# Author: Jason.Yu &lt;admin@lnmmp.com&gt;# description: An example of notify script##contact='root@localhost'#notify() &#123;#mailsubject=\"`hostname` to be $1: $2 floating\"#mailbody=\"`date '+%F %H:%M:%S'`: vrrp transition, `hostname` changed to be $1\"#echo$mailbody | mail -s \"$mailsubject\"$contact#&#125;case \"$1\" in master)# notify master $2 echo \"`date +%c` success to get Vip,start-up haproxy.\" &gt;&gt; /etc/keepalived/scripts/master.log systemctl restart haproxy.service exit 0 ;; backup)# notify backup $2 # 在节点切换成backup状态时，无需刻意停止haproxy服务，防止chk_maintaince和chk_haproxy多次对haproxy服务操作； echo \"`date +%c` host \"$2\" is backup. \" &gt;&gt; /etc/keepalived/scripts/backup.log exit 0 ;; fault)# notify fault $2# 同上 kepid=`pidof keepalived` if [ $kepid == \"\" ] then echo \"`date +%c` no keepalived process id\" &gt;&gt; /etc/keepalived/scripts/fault.log else echo \"`date +%c` will stop keepalived \" &gt;&gt; /etc/keepalived/scripts/fault.log systemctl stop keepalived.service fi exit 0 ;; stop) pid=`pidof haproxy` echo \"`date +%c` stop host \"$2\" is haproxy\" &gt;&gt; /etc/keepalived/scripts/stop.log kill -9 $pid ;; * ) echo'Usage: `basename $0` &#123;master|backup|fault&#125;' exit 1 ;; esac 2.2 配置haproxy 1[root@node2 ~]# vim /etc/haproxy/haproxy.cfg 改为 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273global # to have these messages end up in /var/log/haproxy.log you will # need to: # # 1) configure syslog to accept network log events. This is done # by adding the '-r' option to the SYSLOGD_OPTIONS in # /etc/sysconfig/syslog # # 2) configure local2 events to go to the /var/log/haproxy.log # file. A line like the following can be added to # /etc/sysconfig/syslog # # local2.* /var/log/haproxy.log # log 127.0.0.1 local2 chroot /var/lib/haproxy #修改haproxy的工作目录至指定的目录并在放弃权限之前执行chroot()操作。 pidfile /var/run/haproxy.pid maxconn 4000 #设定每个haproxy进程所接受的最大并发连接数。 user haproxy group haproxy daemon #让haproxy以守护进程的方式工作于后台。 # turn on stats unix socket stats socket /var/lib/haproxy/stats#---------------------------------------------------------------------# common defaults that all the 'listen' and 'backend' sections will# use if not designated in their block#---------------------------------------------------------------------defaults mode http #设定实例的运行模式或协议。 log global #为每个实例启用事件和流量日志，因此可用于所有区段。 option httplog option dontlognull option http-server-close option forwardfor except 127.0.0.0/8 option redispatch #当serverId对应的服务器挂掉后，强制定向到其他健康的服务器 retries 3 timeout http-request 10s timeout queue 1m timeout connect 10s timeout client 1m timeout server 1m timeout http-keep-alive 10s timeout check 10s #心跳检测超时 maxconn 3000listen stats mode http bind 0.0.0.0:1080 stats enable stats hide-version stats uri /haproxyadmin?stats stats realm Haproxy\\ Statistics stats auth admin:admin stats admin if TRUEfrontend http-in #指定前端服务 bind *:80 #指定监听端口 mode http log global option httpclose option logasap option dontlognull capture request header Host len 20 capture request header Referer len 60 default_backend serversbackend servers balance roundrobin #使用roundrobin算法 server websrv1 172.16.10.203:80 check maxconn 2000 server websrv2 172.16.10.204:80 check maxconn 2000 测试 1[root@node2 ~]# haproxy -c -f /etc/haproxy/haproxy.cfg 2.3 配置日志 1[root@node2 ~]# vim /etc/rsyslog.conf 增加一条 1local2.* /var/log/haproxy.log 修改日志等级 1[root@node1 ~]# vim /etc/sysconfig/rsyslog 改为 12345# Options for rsyslogd# Syslogd options are deprecated since rsyslog v3.# If you want to use them, switch to compatibility mode 2 by \"-c 2\"# See rsyslogd(8) for more detailsSYSLOGD_OPTIONS=\"-c 2 -r\" 3 node3配置123456[root@node3 ~]# yum install httpd -y[root@node3 ~]# firewall-cmd --permanent --add-service=http[root@node3 ~]# firewall-cmd --reload [root@node3 ~]# systemctl enable httpd.service [root@node3 ~]# systemctl start httpd.service[root@node3 ~]# vim /var/www/html/index.html 写入 1&lt;h1&gt;WEB1/10.199.200.203/h1&gt; 4 node4配置123456[root@node4 ~]# yum install httpd -y[root@node4 ~]# firewall-cmd --permanent --add-service=http[root@node4 ~]# firewall-cmd --reload [root@node4 ~]# systemctl enable httpd.service [root@node4 ~]# systemctl start httpd.service[root@node4 ~]# vim /var/www/html/index.html 写入 1&lt;h1&gt;WEB2/10.199.200.204/h1&gt; 5.测试 1.直接用浏览器访问172.16.0.10，看是否网页有变动。 2.down掉node1看VIP是否切换到node2上。 结束","categories":[{"name":"HA","slug":"HA","permalink":"/categories/HA/"}],"tags":[{"name":"HA","slug":"HA","permalink":"/tags/HA/"},{"name":"Keepalived","slug":"Keepalived","permalink":"/tags/Keepalived/"}],"keywords":[{"name":"HA","slug":"HA","permalink":"/categories/HA/"}]},{"title":"elasticsearch+logstash+Kibana+beats+redis安装配置","slug":"elasticsearch+logstash+Kibana+beats+redis","date":"2016-11-08T09:36:35.287Z","updated":"2016-11-08T09:36:35.287Z","comments":true,"path":"2016/11/08/elasticsearch+logstash+Kibana+beats+redis/","link":"","permalink":"/2016/11/08/elasticsearch+logstash+Kibana+beats+redis/","excerpt":"简介 Logstash是一个开源的用于收集，分析和存储日志的工具。 Kibana4用来搜索和查看Logstash已索引的日志的web接口。这两个工具都基于Elasticsearch。 + Logstash: Logstash服务的组件，用于处理传入的日志。 + Elasticsearch: 存储所有日志 + Kibana 4: 用于搜索和可视化的日志的Web界面，通过nginx反代 + Logstash Forwarder: 安装在将要把日志发送到logstash的服务器上，作为日志转发的道理，通过 lumberjack 网络协议与 Logstash 服务通讯,logstash-forwarder要被beats替代。","text":"简介 Logstash是一个开源的用于收集，分析和存储日志的工具。 Kibana4用来搜索和查看Logstash已索引的日志的web接口。这两个工具都基于Elasticsearch。 + Logstash: Logstash服务的组件，用于处理传入的日志。 + Elasticsearch: 存储所有日志 + Kibana 4: 用于搜索和可视化的日志的Web界面，通过nginx反代 + Logstash Forwarder: 安装在将要把日志发送到logstash的服务器上，作为日志转发的道理，通过 lumberjack 网络协议与 Logstash 服务通讯,logstash-forwarder要被beats替代。 1. 安装elasticsearch123456[root@node4 ~]# yum localinstall jdk-8u101-linux-x64.rpm [root@node4 ~]# wget https://download.elastic.co/elasticsearch/release/org/elasticsearch/distribution/rpm/elasticsearch/2.3.4/elasticsearch-2.3.4.rpm[root@node4 ~]# yum localinstall elasticsearch-2.3.4.rpm [root@node4 ~]# systemctl enable elasticsearch.service [root@node4 ~]# mkdir -p /data/elasticsearch/&#123;data,logs&#125;[root@node4 ~]# chown -R elasticsearch.elasticsearch /data/elasticsearch/ elasticsearch配置文件位于ES_HOME/config目录中，yum安装的就在etc目录下。该目录中有两个文件elasticsearch.yml配置elasticsearch不同模块，logging.yml配置elasticsearch日志。配置格式是YAML。如果使用json格式，需要将elasticsearch.yml重命名为elasticsearch.json，同时，需要将文件中的配置参数转换成json格式。\\ 123456789[root@node4 ~]# vim /etc/elasticsearch/elasticsearch.ymlcluster.name: elk-logsnode.name: $&#123;HOSTNAME&#125;path.data: /data/elasticsearch/datapath.logs: /data/elasticsearch/logsbootstrap.mlockall: truebootstrap.max_open_files: truenetwork.host: 10.199.200.204http.port: 9200 注: 数据目录可以设置为多个如：path.data: [“/data/elasticsearch/data1”,”/data/elasticsearch/data2”] 或者 path.data: /data/elasticsearch/data1, /data/elasticsearch/data2。 如果想以主机名命令节点名称，同时，该服务器上只运行单个elasticsearch实例，可以设置为${HOSTNAME}变量，将从环境变量中获取主机名。也可以设置成${prompt.text}，在启动时，需要键入名称。 1234567891011121314[root@node4 ~]# systemctl start elasticsearch.service[root@node4 ~]# curl -XGet 10.199.200.204:9200 &#123; \"name\" : \"Jane Kincaid\", \"cluster_name\" : \"elasticsearch\", \"version\" : &#123; \"number\" : \"2.3.4\", \"build_hash\" : \"e455fd0c13dceca8dbbdbb1665d068ae55dabe3f\", \"build_timestamp\" : \"2016-06-30T11:24:31Z\", \"build_snapshot\" : false, \"lucene_version\" : \"5.5.0\" &#125;, \"tagline\" : \"You Know, for Search\" &#125; 2. 安装kibana123456789[root@node4 ~]# wget https://download.elastic.co/kibana/kibana/kibana-4.5.3-1.x86_64.rpm[root@node4 ~]# yum localinstall kibana-4.5.3-1.x86_64.rpm[root@node4 ~]# vim /opt/kibana/config/kibana.yml server.port: 5601 server.host: \"10.199.200.204\" elasticsearch.url: \"http://10.199.200.204:9200\"[root@node4 ~]# systemctl enable kibana.service[root@node4 ~]# systemctl start kibana.service 3. 安装插件12345678910111213[root@node4 ~]# /usr/share/elasticsearch/bin/plugin install mobz/elasticsearch-head[root@node4 ~]# /usr/share/elasticsearch/bin/plugin install lmenezes/elasticsearch-kopf[root@node4 ~]# /usr/share/elasticsearch/bin/plugin install license[root@node4 ~]# /usr/share/elasticsearch/bin/plugin install graph[root@node4 ~]# /usr/share/elasticsearch/bin/plugin install marvel-agent[root@node4 ~]# /opt/kibana/bin/kibana plugin --install elasticsearch/marvel/latest[root@node4 ~]# /opt/kibana/bin/kibana plugin --install elasticsearch/graph/latest浏览器访问http://10.199.200.204:9200/_plugin/head/http://10.199.200.204:9200/_plugin/kopf/ http://10.199.200.204:5601/app/marvel http://10.199.200.204:5601/app/kibana 4. 安装logstash1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374[root@node4 ~]# wget https://download.elastic.co/logstash/logstash/packages/centos/logstash-2.3.4-1.noarch.rpm[root@node4 ~]# yum localinstall logstash-2.3.4-1.noarch.rpm[root@node4 ~]# usermod -a -G root logstash [root@node4 ~]# service logstash start[root@node4 ~]# vim /etc/logstash/conf.d/topbeat-redis.confinput &#123; redis &#123; host =&gt; \"127.0.0.1\" port =&gt; \"6379\" data_type =&gt; \"list\" key =&gt; \"topbeat\" threads =&gt; 10 &#125;&#125;output &#123; elasticsearch &#123; hosts =&gt; \"10.199.200.204:9200\" sniffing =&gt; true index =&gt; \"topbeat-%&#123;+YYYY.MM.dd&#125;\" workers =&gt; 10 &#125;&#125;[root@node4 ~]# vim /etc/logstash/conf.d/filebeat-redis.confinput &#123; redis &#123; host =&gt; \"127.0.0.1\" port =&gt; \"6379\" data_type =&gt; \"list\" key =&gt; \"filebeat\" threads =&gt; 10 &#125;&#125;output &#123; elasticsearch &#123; hosts =&gt; \"10.199.200.204:9200\" sniffing =&gt; true index =&gt; \"filebeat-%&#123;+YYYY.MM.dd&#125;\" workers =&gt; 10 &#125;&#125;[root@node4 ~]# vim /etc/logstash/conf.d/packetbeat-redis.confinput &#123; redis &#123; host =&gt; \"127.0.0.1\" port =&gt; \"6379\" data_type =&gt; \"list\" key =&gt; \"packetbeat\" threads =&gt; 10 &#125;&#125;output &#123; elasticsearch &#123; hosts =&gt; \"10.199.200.204:9200\" sniffing =&gt; true index =&gt; \"packetbeat-%&#123;+YYYY.MM.dd&#125;\" workers =&gt; 10 &#125;&#125; 验证配置文件 1[root@node4 ~]# /opt/logstash/bin/logstash --configtest -f /etc/logstash/conf.d/* 5. 安装redisredis这里不详细说明，最好是用集群，由于这里是试验所以就单节点。 1234567[root@node4 ~]# yum -y install epel-release[root@node4 ~]# yum -y install redis[root@node4 ~]# vim /etc/redis bind 127.0.0.1 10.199.200.204 maxmemory 4G[root@node4 ~]# systemctl enable redis.service[root@node4 ~]# systemctl start redis.service 6. 客户端配置6.1 安装filebeat12345678910111213141516171819202122[root@node1 ~]# yum localinstall https://download.elastic.co/beats/filebeat/filebeat-1.2.3-x86_64.rpm[root@node1 ~]# vim /etc/filebeat/filebeat.yml filebeat: prospectors: - paths: - \"/opt/gis/tomcat/logs/catalina.out\" fields: type: gis-tomcat-logsoutput: redis: host: \"10.199.200.204\" port: 6379 save_topology: true index: \"filebeat\" #redis keyname db: 0 db_topology: 1 reconnect_interval: 1[root@node1 ~]# curl -XPUT 'http://10.199.200.204:9200/_template/filebeat?pretty' -d@/etc/filebeat/filebeat.template.json [root@node1 ~]# service filebeat restart 6.2 安装topbeat1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162[root@node1 ~]# yum localinstall https://download.elastic.co/beats/topbeat/topbeat-1.2.3-x86_64.rpm[root@node1 ~]# curl -XPUT 'http://10.199.200.204:9200/_template/topbeat' -d@/etc/topbeat/topbeat.template.json[root@node1 ~]# vim /etc/filebeat/topbeat.ymlinput: # In seconds, defines how often to read server statistics period: 10 # Regular expression to match the processes that are monitored # By default, all the processes are monitored procs: [\".*\"] # Statistics to collect (all enabled by default) stats: # per system statistics, by default is true system: true # per process statistics, by default is true process: true # file system information, by default is true filesystem: true # cpu usage per core, by default is false cpu_per_core: falseoutput: redis: # Set the host and port where to find Redis. host: \"10.199.200.204\" port: 6379 # Uncomment out this option if you want to store the topology in Redis. # The default is false. save_topology: true # Optional index name. The default is topbeat and generates topbeat keys. index: \"topbeat\" # Optional Redis database number where the events are stored # The default is 0. db: 0 # Optional Redis database number where the topology is stored # The default is 1. It must have a different value than db. db_topology: 1 # Optional password to authenticate with. By default, no # password is set. # password: \"\" # Optional Redis initial connection timeout in seconds. # The default is 5 seconds. timeout: 5 # Optional interval for reconnecting to failed Redis connections. # The default is 1 second. reconnect_interval: 1[root@node1 ~]# service topbeat start 6.3 安装packetbeat1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768[root@node1 ~]# yum localinstall https://download.elastic.co/beats/packetbeat/packetbeat-1.2.3-x86_64.rpm [root@node1 ~]# curl -XPUT 'http://10.199.200.204:9200/_template/packetbeat' -d@/etc/packetbeat/packetbeat.template.json[root@node1 ~]# vim /etc/filebeat/packetbeat.ymlprotocols: dns: ports: [53] include_authorities: true include_additionals: true http: ports: [80, 8080, 8081, 5000, 8002] memcache: ports: [11211] mysql: ports: [3306] pgsql: ports: [5432] redis: ports: [6379] thrift: ports: [9090] mongodb: ports: [27017] tomcat: ports: [8080]output: redis: # Set the host and port where to find Redis. host: \"10.199.200.204\" port: 6379 # Uncomment out this option if you want to store the topology in Redis. # The default is false. save_topology: true # Optional index name. The default is packetbeat and generates packetbeat keys. index: \"packetbeat\" # Optional Redis database number where the events are stored # The default is 0. db: 0 # Optional Redis database number where the topology is stored # The default is 1. It must have a different value than db. db_topology: 1 # Optional password to authenticate with. By default, no # password is set. # password: \"\" # Optional Redis initial connection timeout in seconds. # The default is 5 seconds. timeout: 5 # Optional interval for reconnecting to failed Redis connections. # The default is 1 second. reconnect_interval: 1 [root@node1 ~]# service packetbeat start 7. 加载kibana Dashboards12345678910官方提供了一些仪表盘样本方便我们查看监视，项目地址：https://github.com/elastic/beats-dashboards加载方法如下：[root@node1 ~]# wget http://download.elastic.co/beats/dashboards/beats-dashboards-1.0.0.tar.gz[root@node1 ~]# tar xzvf beats-dashboards-1.0.0.tar.gz[root@node1 ~]# cd beats-dashboards-1.0.0/[root@node1 ~]#./load.sh http://10.199.200.204:9200https://github.com/packetb-old 结束","categories":[{"name":"ELK","slug":"ELK","permalink":"/categories/ELK/"}],"tags":[{"name":"redis","slug":"redis","permalink":"/tags/redis/"},{"name":"ELK","slug":"ELK","permalink":"/tags/ELK/"}],"keywords":[{"name":"ELK","slug":"ELK","permalink":"/categories/ELK/"}]},{"title":"redmine的安装部署","slug":"redmine","date":"2016-11-08T09:04:30.684Z","updated":"2016-11-08T09:04:30.684Z","comments":true,"path":"2016/11/08/redmine/","link":"","permalink":"/2016/11/08/redmine/","excerpt":"安装 操作系统：centos6.3redmine版本：2.3虚拟机IP：192.168.1.44mysql版本：mysql-5.1.69nginx版本: nginx/1.4.2ruby版本：ruby 1.9.3p392 (2013-02-22 revision 39386) [i686-linux]rubygems: 1.8.23","text":"安装 操作系统：centos6.3redmine版本：2.3虚拟机IP：192.168.1.44mysql版本：mysql-5.1.69nginx版本: nginx/1.4.2ruby版本：ruby 1.9.3p392 (2013-02-22 revision 39386) [i686-linux]rubygems: 1.8.23 安装ruby with libyaml12345wget http://pyyaml.org/download/libyaml/yaml-0.1.4.tar.gztar -zxvf yaml-0.1.4.tar.gzcd yaml-0.1.4./configure --prefix=/usr/localmake &amp;&amp; make install 安装ruby123456wget ftp://ftp.ruby-lang.org/pub/ruby/1.9/ruby-1.9.3-p392.tar.gztar -zxvf ruby-1.9.3-p392./configure --prefix=/usr/local --enable-shared-disable-install-doc-with-opt-dir=/usr/local/libmake &amp;&amp; make install安装完成后查看ruby 版本：ruby -v 安装mysqlserver1yum -y install mysql-serverz redmine安装123456http://rubyforge.org/frs/?group_id=1850mkdir datacd datamkdir webcd webtar -zxvf redmine-2.3.2.tar.gz 配置mysql数据库12CREATE DATABASE redmine CHARACTER SET utf8;GRANT ALL PRIVILEGES ON redmine.* TO 'redmine'@'localhost' IDENTIFIED BY 'my_password'; 数据库连接配置123456789cd /data/web/redmine-2.3.2cp config/database.yml.example config/database.yml打开database.ymlproduction: adapter: mysql2 database: redmine host: localhost username: redmine password: my_password 安装依赖的bundler123gem install bundlerbundle install --without development testbundle install --without development test rmagick 生成session存储加密信息和数据表1rake generate_secret_token 创建数据库对象1RAILS_ENV=production rake db:migrate 数据库默认数据集12RAILS_ENV=production rake redmine:load_default_dataRAILS_ENV=production REDMINE_LANG=fr rake redmine:load_default_data 文件日志权限12345groupadd redmineuseradd -g redmine redminemkdir -p /data/web/redmine-2.3.2 /public/plugin_assetssudo chown -R redmine:redmine files log tmp public/plugin_assetssudo chmod -R 755 files log tmp public/plugin_assets 测试安装1234ruby script/rails server webrick -e productionlogin: adminpassword: adminhttp:localhost:3000 安装方式2使用rbenv安装ruby1234567891011sudo apt-get install gitgit clone git://github.com/sstephenson/rbenv.git ~/.rbenvecho 'export PATH=\"$HOME/.rbenv/bin:$PATH\"' &gt;&gt; ~/.bash_profileecho 'eval \"$(rbenv init -)\"' &gt;&gt; ~/.bash_profile### 安装 ruby-buildmkdir -p ~/.rbenv/pluginscd ~/.rbenv/pluginsgit clone git://github.com/sstephenson/ruby-build.gitsource ~/.bash_profile 安装 Ruby123456 sudo apt-get install build-essential autoconf automake bison libtool \\openssl libreadline6 libreadline6-dev curl zlib1g zlib1g-dev libssl-dev \\libyaml-dev libsqlite3-dev sqlite3 libxml2-dev libxslt-dev libc6-dev ncurses-devrbenv install 1.9.3-p125 rbenv rehash 安装mysql1sudo apt-get install mysql-server h3. 下载安装redminewget http://www.redmine.org/releases/redmine-2.4.1.tar.gz 12345678910tar -zxvf redmine-2.4.1.tar.gzsudo vi config/ databases.ymlCREATE DATABASE redmine CHARACTER SET utf8;CREATE USER 'redmine'@'localhost' IDENTIFIED BY 'my_password';GRANT ALL PRIVILEGES ON redmine.* TO 'redmine'@'localhost';gem install bundlerbundle install --without development test (报错1)解决方式：sudo apt-get install libmysql-ruby libmysqlclient-dev（报错2）解决方式：gem install net-ldap –version 0.3.1（报错3）解决方式：sudo apt-get install imagemagick libmagickwand-dev 123456789bundle install --without development test rmagickrake generate_secret_tokenRAILS_ENV=production rake db:migrateRAILS_ENV=production rake redmine:load_default_datamkdir -p tmp tmp/pdf public/plugin_assetssudo chown -R redmine:redmine files log tmp public/plugin_assetssudo chmod -R 755 files log tmp public/plugin_assetsruby script/rails server webrick -e production","categories":[{"name":"redmine","slug":"redmine","permalink":"/categories/redmine/"}],"tags":[{"name":"redmine","slug":"redmine","permalink":"/tags/redmine/"}],"keywords":[{"name":"redmine","slug":"redmine","permalink":"/categories/redmine/"}]},{"title":"hexo博客搭建","slug":"Hexoblog","date":"2016-11-08T03:26:36.018Z","updated":"2016-11-08T03:26:36.018Z","comments":true,"path":"2016/11/08/Hexoblog/","link":"","permalink":"/2016/11/08/Hexoblog/","excerpt":"","text":"一、什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装 安装 Hexo 只需几分钟时间，若您在安装过程中遇到问题或无法找到解决方式，请提交问题，我会尽力解决您的问题。 安装前提安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序： Node.js Git 如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。1$ npm install -g hexo-cli 如果您的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。 Mac 用户您在编译时可能会遇到问题，请先到 App Store 安装 Xcode，Xcode 完成后，启动并进入 Preferences -&gt; Download -&gt; Command Line Tools -&gt;Install 安装命令行工具。 安装 Git Windows：下载并安装 git. Mac：使用 Homebrew, MacPorts 或下载 安装程序 安装。 Linux (Ubuntu, Debian)：sudo apt-get install git-core Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core安装 Node.js 安装 Node.js 的最佳方式是使用 nvm。 cURL:1$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh Wget:1$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 安装完成后，重启终端并执行下列命令即可安装 Node.js。1$ nvm install stable 或者您也可以下载 安装程序来安装。 安装 Hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。 1$ npm install -g hexo-cli 安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。123456$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install[root@vmware-130 ~]# rpm -qa|grep pcrepcre-7.8-6.el6.x86_64pcre-devel-7.8-6.el6.x86_64 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml网站的 配置 信息，您可以在此配置大部分的参数。 package.json应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 scaffolds模板 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 source资源文件夹是存放用户资源的地方。除_posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到public 文件夹，而其他文件会被拷贝过去。 themes主题 文件夹。Hexo 会根据主题来生成静态页面。您可以在 _config.yml 中修改大部份的配置。 网站参数 描述title网站标题subtitle 网站副标题description 网站描述author您的名字language 网站使用的语言timezone 网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。 网址 参数 描述 默认值 url 网址 root 网站根目录 permalink 文章的 永久链接格式 :year/:month/:day/:title/ permalink_default 永久链接中各部分的默认值 网站存放在子目录 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/ 参数 描述 默认值 source_dir 资源文件夹，这个文件夹用来存放内容。 source public_dir 公共文件夹，这个文件夹用于存放生成的站点文件 public archive_dir 归档文件夹 categories code_dir Include code 文件夹 downloads/code i18n_dir 国际化（i18n）文件夹 lang skip_render 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 参数 描述 默认值source_dir 资源文件夹，这个文件夹用来存放内容。 sourcepublic_dir 公共文件夹，这个文件夹用于存放生成的站点文件。 publictag_dir 标签文件夹 tagsarchive_dir 归档文件夹 archivescategory_dir 分类文件夹 categoriescode_dir Include code 文件夹 downloads/codei18n_dir 国际化（i18n）文件夹 :langskip_render 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 init1$ hexo init [folder] 新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。 new1$ hexo new [layout] &lt;title&gt; 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。 generate1$ hexo generate 生成静态文件。 选项 描述 -d, --deploy 文件生成后立即部署网站 -w, --watch 监视文件变动 publish1$ hexo publish [layout] &lt;filename&gt; 发表草稿 server1$ hexo server 启动服务器。默认情况下，访问网址为： http://localhost:4000/。 deploy1$ hexo deploy 部署网站。 render1$ hexo render &lt;file1&gt; [file2] ... 渲染文件。 migrate1$ hexo migrate &lt;type&gt; 从其他博客系统 迁移内容。 clean12$ hexo clean list1$ hexo list &lt;type&gt; 主配置文件模板：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: AlexZhousubtitle: This is Aexl blogdescription: msbgn blogauthor: Rongfu Zhoulanguage: zh-CNtimezone: Asia/Shanghai# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: /root: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: true tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 3pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: icarus#duoshuo_shortname: carl1990.duoshuo.com#duoshuo: true# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://zhourongfu@github.com/zhourongfu/zhourongfu.github.io.git branch: master 主题模板： 我采用的是icarus主题，根据自己喜欢的主题配置，每个主题的配置方式有差异 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980# Menusmenu: 首页: / python: /python 归档: /archives 关于: /about# Customizecustomize: logo: enabled: true width: 40 height: 40 url: images/logo.png profile: enabled: true # Whether to show profile bar avatar: css/images/avatar.png gravatar: # Gravatar email address, if you enable Gravatar, your avatar config will be overriden author: AlexZhou author_title: Time Flies(岁月如梭) location: shenzhen, China follow: https://github.com/zhourongfu/ highlight: monokai sidebar: right # sidebar position, options: left, right thumbnail: true # enable posts thumbnail, options: true, false favicon: /favicon.ico # path to favicon social_links: github: https://github.com/zhourongfu/ weixin: http://mp.weixin.qq.com/s?__biz=MzI5NzMxMDQ1NA==&amp;mid=2247483651&amp;idx=1&amp;sn=58ad9ee21c33243688628512624db18f&amp;chksm=ecb6409adbc1c98c3561ce437435666ccd296f0d6a90999e3d2a9dc7d82cc7cbf435896be5a3#rd qq: http://wpa.qq.com/msgrd?v=3&amp;uin=508095413&amp;site=qq&amp;menu=yes social_link_tooltip: true # enable the social link tooltip, options: true, false# Widgetswidgets: - recent_posts - category - archive - tag - tagcloud - links# Searchsearch: insight: true # you need to install `hexo-generator-json-content` before using Insight Search swiftype: # enter swiftype install key here baidu: true # you need to disable other search engines to use Baidu search, options: true, false# Commentcomment: #disqus: hexo-theme-icarus # enter disqus shortname here duoshuo: carl1990 # enter duoshuo shortname here youyan: # enter youyan uid here# Shareshare: bdshare # options: jiathis, bdshare, addtoany, defaultdonate: enable: true text: 打赏我的人，据说都找到了女朋友~~ wechat: http://www.msbgn.cn/msbgn/xpchatpay.png alipay: http://www.msbgn.cn/msbgn/wechatpay.png web: true# Pluginsplugins: lightgallery: true # options: true, false justified-gallery: true # options: true, false google_analytics: # enter the tracking ID for your Google Analytics google_site_verification: # enter Google site verification code baidu_analytics: # enter Baidu Analytics hash key# Miscellaneousmiscellaneous: open_graph: # see http://ogp.me fb_app_id: fb_admins: twitter_id: google_plus: links: 百度: http://www.baidu.com 同舟商城: http://www.10ytao.com 铁匠运维: http://www.tiejiang.org 51运维: http://www.51ou.com 运维派: http://www.yunweipai.com Linux公社: http://www.linuxidc.cm 安装已经完成，下一节是修改主题相关操作、增加评论模块，打赏、分享、站内搜索。","categories":[{"name":"hexo","slug":"hexo","permalink":"/categories/hexo/"}],"tags":[{"name":"科技","slug":"科技","permalink":"/tags/科技/"},{"name":"hexo","slug":"hexo","permalink":"/tags/hexo/"}],"keywords":[{"name":"hexo","slug":"hexo","permalink":"/categories/hexo/"}]},{"title":"Codis 高可用负载均衡群集的搭建与使用2","slug":"Codis2","date":"2016-11-04T04:19:17.741Z","updated":"2016-11-04T04:19:17.741Z","comments":true,"path":"2016/11/04/Codis2/","link":"","permalink":"/2016/11/04/Codis2/","excerpt":"","text":"一、部署Keepalived + haproxy 高可用负载均衡安装haproxy、keepalived (43.130、43.132 机器上操作) 1.查看系统内核是否支持tproxy 1234[root@vmware-130 ~]# grep TPROXY /boot/config-`uname -r` CONFIG_NETFILTER_TPROXY=mCONFIG_NETFILTER_XT_TARGET_TPROXY=m内核为2.6.32-220.el6.x86_64，支持TPROXY； 2.源码安装pcre-8.01 123[root@vmware-130 ~]# rpm -qa|grep pcrepcre-7.8-6.el6.x86_64pcre-devel-7.8-6.el6.x86_64 系统已经rpm形式安装了pcre，但安装haproxy时，提示找不到pcre的库文件，看了haproxy的Makefile文件，指定pcre的为/usr/local下，故再源码安装一个pcre-8.01，如下(如果不重新安装，可以改makefile文件或把库文件软链到makefile文件指定的路径) 1234[root@vmware-130 ~]# cd /data/packages[root@vmware-130 ~]# tar -zxf pcre-8.37.tar.gz &amp;&amp; cd pcre-8.37[root@vmware-130 pcre-8.36 ]# ./configure --disable-shared --with-pic[root@vmware-130 pcre-8.36 ]# make &amp;&amp; make install 3.安装 haproxy-1.4.22 12345678[root@vmware-130 ~]# cd /data/packages[root@vmware-130 ~]# tar xf haproxy-1.4.26.tar.gz[root@vmware-130 ~]# cd haproxy-1.4.26[root@vmware-130 haproxy-1.4.26 ]# make TARGET=linux26 CPU=x86_64 USE_STATIC_PCRE=1 USE_LINUX_TPROXY=1[root@vmware-130 haproxy-1.4.26 ]# make install target=linux26[root@vmware-130 haproxy-1.4.26 ]# mkdir -p /usr/local/haproxy/sbin[root@vmware-130 haproxy-1.4.26 ]# mkdir -p /data/haproxy/&#123;conf,run,logs&#125;[root@vmware-130 haproxy-1.4.26 ]# ln -s /usr/local/sbin/haproxy /usr/local/haproxy/sbin 4.创建haproxy启动脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109[root@vmware-130 ~]# vim /etc/init.d/haproxy #!/bin/sh# haproxy# chkconfig: 35 85 15# description: HAProxy is a free, very fast and reliable solution \\# offering high availability, load balancing, and \\# proxying for TCP and HTTP-based applications# processname: haproxy# config: /data/haproxy/conf/haproxy.cfg# pidfile: /data/haproxy/run/haproxy.pid# Source function library.. /etc/rc.d/init.d/functions# Source networking configuration.. /etc/sysconfig/network# Check that networking is up.[ \"$NETWORKING\" = \"no\" ] &amp;&amp; exit 0config=\"/data/haproxy/conf/haproxy.cfg\"exec=\"/usr/local/haproxy/sbin/haproxy\"prog=$(basename $exec)[ -e /etc/sysconfig/$prog ] &amp;&amp; . /etc/sysconfig/$proglockfile=/var/lock/subsys/haproxycheck() &#123; $exec -c -V -f $config&#125;start() &#123; $exec -c -q -f $config if [ $? -ne 0 ]; then echo \"Errors in configuration file, check with $prog check.\" return 1 fi echo -n $\"Starting $prog: \" # start it up here, usually something like \"daemon $exec\" daemon $exec -D -f $config -p /data/haproxy/run/$prog.pid retval=$? echo [ $retval -eq 0 ] &amp;&amp; touch $lockfile return $retval&#125;stop() &#123; echo -n $\"Stopping $prog: \" # stop it here, often \"killproc $prog\" killproc $prog retval=$? echo [ $retval -eq 0 ] &amp;&amp; rm -f $lockfile return $retval&#125;restart() &#123; $exec -c -q -f $config if [ $? -ne 0 ]; then echo \"Errors in configuration file, check with $prog check.\" return 1 fi stop start&#125;reload() &#123; $exec -c -q -f $config if [ $? -ne 0 ]; then echo \"Errors in configuration file, check with $prog check.\" return 1 fi echo -n $\"Reloading $prog: \" $exec -D -f $config -p /data/haproxy/run/$prog.pid -sf $(cat /data/haproxy/run/$prog.pid) retval=$? echo return $retval&#125;force_reload() &#123; restart&#125;fdr_status() &#123; status $prog&#125;case \"$1\" in start|stop|restart|reload) $1 ;; force-reload) force_reload ;; checkconfig) check ;; status) fdr_status ;; condrestart|try-restart) [ ! -f $lockfile ] || restart ;; *) echo $\"Usage: $0 &#123;start|stop|status|checkconfig|restart|try-restart|reload|force-reload&#125;\" exit 2esac 备注：此脚本stop的时候有问题，有待解决。 123456#添加haproxy服务#添加haproxy服务[root@vmware-130 ~]# echo \"net.ipv4.ip_nonlocal_bind = 1\" &gt;&gt; /etc/rsysctl.conf[root@vmware-130 ~]# sysctl -p[root@vmware-130 ~]# chmod 755 /etc/init.d/haproxy[root@vmware-130 ~]# chkconfig --add haproxy[root@vmware-130 ~]# chkconfig haproxy on 5.安装keepalived 123456[root@vmware-130 ~]# cd /data/packages[root@vmware-130 ~]# tar zxvf keepalived-1.2.16.tar.gz[root@vmware-130 ~]# cd keepalived-1.2.16[root@vmware-130 keepalived-1.2.16 ]# ./configure --with-kernel-dir=/usr/src/kernels/2.6.32-504.16.2.el6.x86_64/\\\\若/usr/src/kernels/目录下为空，那么安装kernel-headers和kernel-devel包 yum install -y kernel-header kernel-devel [root@vmware-130 keepalived-1.2.16 ]# make &amp;&amp; make install 6.配置keepalived,添加keepalived 服务 123456[root@vmware-130 ~]# cp /usr/local/etc/rc.d/init.d/keepalived /etc/rc.d/init.d/[root@vmware-130 ~]# cp /usr/local/etc/sysconfig/keepalived /etc/sysconfig/[root@vmware-130 ~]# mkdir -p /data/keepalived/&#123;conf,scripts&#125;[root@vmware-130 ~]# cp /usr/local/sbin/keepalived /usr/sbin/[root@vmware-130 ~]# chkconfig --add keepalived[root@vmware-130 ~]# chkconfig keepalived on 7 配置haproxy.cfg配置文件( 43.130, 43.132 配置，haproxy.cfg配置文件完全一样 ) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051[root@vmware-130 ~]# vim /usr/local/haproxy/conf/haproxy.cfg########### 全局配置 #########globallog 127.0.0.1 local0 errchroot /usr/local/haproxydaemonnbproc 1group nobodyuser nobodypidfile /usr/local/haproxy/run/haproxy.pidulimit-n 65536#spread-checks 5m #stats timeout 5m#stats maxconn 100######## 默认配置 ############defaultsmode tcp #默认的模式mode &#123; tcp|http|health &#125;，tcp是4层，http是7层，health只会返回OKretries 3 #两次连接失败就认为是服务器不可用，也可以通过后面设置option redispatch #当serverId对应的服务器挂掉后，强制定向到其他健康的服务器option abortonclose #当服务器负载很高的时候，自动结束掉当前队列处理比较久的链接maxconn 32000 #默认的最大连接数timeout connect 5000ms #连接超时timeout client 30000ms #客户端超时timeout server 30000ms #服务器超时#timeout check 2000 #心跳检测超时log 127.0.0.1 local3 err #[err warning info debug] ######## proxy 配置#################listen proxy_status bind 0.0.0.0:45001mode tcpbalance roundrobinserver codis_proxy_1 192.168.43.130:19000 weight 1 maxconn 10000 check inter 10sserver codis_proxy_2 192.168.43.131:19000 weight 1 maxconn 10000 check inter 10sserver codis_proxy_3 192.168.43.132:19000 weight 1 maxconn 10000 check inter 10s ######## 统计页面配置 ########listen admin_statsbind 0.0.0.0:8099 #监听端口mode http #http的7层模式option httplog #采用http日志格式#log 127.0.0.1 local0 errmaxconn 10stats refresh 30s #统计页面自动刷新时间stats uri /stats #统计页面urlstats realm XingCloud\\ Haproxy #统计页面密码框上提示文本stats auth admin:admin #统计页面用户名和密码设置stats hide-version #隐藏统计页面上HAProxy的版本信息stats admin if TRUE 8 配置keepalived.conf配置文件 ( 43.130 上配置，43.132备用配置主要修改参数已经标注 ) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960[root@vmware-130 ~]# vim /data/keepalived/conf/keepalived.conf! Configuration File for keepalived global_defs &#123; notification_email &#123; lwz_benet@163.com &#125; notification_email_from lwz_benet@1163.com smtp_connect_timeout 30 smtp_server 127.0.0.1 router_id HAProxy_DEVEL &#125; vrrp_script chk_haproxy &#123; script \"killall -0 haproxy\" interval 2 &#125; vrrp_instance HAProxy_HA &#123; state BACKUP interface eth0 virtual_router_id 80 priority 100 #备用为90 advert_int 2 nopreempt #设置不强占，防止业务来回切换。 authentication &#123; auth_type PASS auth_pass KJj23576hYgu23IP &#125; track_interface &#123; eth0 &#125; virtual_ipaddress &#123; 192.168.43.100 &#125; track_script &#123; chk_haproxy &#125; #状态通知 notify_master \"/data/keepalived/scripts/mail_notify.py master\" notify_backup \"/data/keepalived/scripts/mail_notify.py backup\" notify_fault \"/data/keepalived/scripts/mail_notify.py fault\" &#125;\\\\拷贝主上面的keepalived.conf到从上，只需修改priority值参数即可。 创建/data/keepalived/scripts/mail_notify.py邮件通知程序：详细请访问：http://liweizhong.blog.51cto.com/1383716/1639917\\\\最后修改下通知信息为英文，中文内容可能会投递失败。 # 配置haproxy日志[root@vmware-130 ~]# vim /etc/rsyslog.d/haproxy.conf$ModLoad imudp$UDPServerRun 514local3.* /data/haproxy/logs/haproxy.loglocal0.* /data/haproxy/logs/haproxy.log[root@vmware-130 ~]# vim /etc/sysconfig/rsyslogSYSLOGD_OPTIONS=\"-c 2 -r -m 0\"[root@vmware-130 ~]# service rsyslog restart 8启动haproxy、keepalived服务。(先启动两个haproxy服务，然后在依次启动master、backup上的keepalived服务) 12[root@vmware-130 ~]# service haproxy start ( 先启动 haproxy 服务 )[root@vmware-130 ~]# service keepalived start 10测试redis-cli客户端访问 1[root@vmware-130 ~]# redis-cli -h 192.168.43.130 -p 45001 备注：redis-cli 命令，codis里面是没有的，我是安装redis服务的，只是用codis而已。 到这里，整个架构已经全部部署完成啦！！！二、Codis 群集架构故障测试 codis-server的HA安装 123456789export GOPATH=/data/go/usr/local/go/bin/go get github.com/ngaut/codis-hacd /data/go/src/github.com/ngaut/codis-hago buildcp codis-ha /data/go/src/github.com/wandoulabs/codis/bin/使用方法：codis-ha --codis-config=dashboard地址:18087 --productName=集群项目名称* 10测试redis-cli客户端访问 使用supervisord管理codis-ha进程 123456789101112131415yum -y install supervisord/etc/supervisord.conf中添加如下内容：[program:codis-ha]autorestart = Truestopwaitsecs = 10startsecs = 1stopsignal = QUITcommand = /data/go/src/github.com/wandoulabs/codis/bin/codis-ha --codis-config=10.10.32.17:18087 --productName=zh_newsuser = rootstartretries = 3autostart = Trueexitcodes = 0,2/etc/init.d/supervisord startchkconfig supervisord on 1.停止任意zookeeper节点，检查codis-proxy，dashboard是否正常. 1234567891011121314151617181920212223242526272829303132[root@vmware-132 scripts]# zkServer.sh statusJMX enabled by defaultUsing config: /usr/local/zookeeper/bin/../conf/zoo.cfgMode: leader \\\\目前此节点提供服务[root@vmware-132 scripts]# zkServer.sh stop \\\\停止此服务，模拟leader挂掉。JMX enabled by defaultUsing config: /usr/local/zookeeper/bin/../conf/zoo.cfgStopping zookeeper ... STOPPED检查zookeeper其他节点是否重新选取 leader。[root@vmware-131 ~]# zkServer.sh statusJMX enabled by defaultUsing config: /usr/local/zookeeper/bin/../conf/zoo.cfgMode: leader \\\\可以看到，vmware-131已经选举为leader.[root@vmware-130 ~]# zkServer.sh statusJMX enabled by defaultUsing config: /usr/local/zookeeper/bin/../conf/zoo.cfgMode: follower redis客户端是否能正常访问到codis-proxy。[root@vmware-130 logs]# redis-cli -h 192.168.43.100 -p 45001192.168.43.100:45001&gt; get mike\"liweizhong\"192.168.43.100:45001&gt; get benet\"lwz\"192.168.43.100:45001&gt; get id\"27\"192.168.43.100:45001&gt; exit[root@vmware-130 logs]# dashboard管理界面是否正常。打开浏览器，访问 http://192.168.43.130:18087/admin/ 2.停止group master,检查group slave是否自动切换主 接下来，我们开始来模拟vmware-130机器上的codis-server master 6379端口挂掉 停止codis-master后，检查codis-ha日志输出如下信息: 打开管理界面，查看到如下信息： 客户端写入新数据，切换后的主是否有新key增加。 12345678910[root@vmware-130 ~]# redis-cli -h 192.168.43.100 -p 45001192.168.43.100:45001&gt; set abc 123OK192.168.43.100:45001&gt; set def 456OK192.168.43.100:45001&gt; get abc\"123\"192.168.43.100:45001&gt; get def\"456\"192.168.43.100:45001&gt; exit 打开管理界面，查看到keys增加两个。 接下来我们恢复vmware-130 codis-server 6379 12345[root@vmware-130 ~]# /usr/local/codis/bin/codis-server /data/codis_server/conf/6379.conf [root@vmware-130 ~]# ps -ef |grep codis-serverroot 2121 1 0 Apr30 ? 00:02:15 /usr/local/codis/bin/codis-server *:6380 root 7470 1 21 16:58 ? 00:00:00 /usr/local/codis/bin/codis-server *:6379 root 7476 1662 0 16:58 pts/0 00:00:00 grep codis-server 这时，我们在管理界面看到如下情况： 备注：当master挂掉时候，redis-ha检测到自动将slave切换为master,但是master恢复后，仍为offline，需要将其删除在添加，就可以成为slave. 按备注那样，我们需要将原来的master 6379先删除，然后再次添加。操作完成后，如下图所示 3.通过dashboard管理界面添加codis-server组，在线迁移、扩展等。 添加新组，添加master,slave . \\此步省略，之前已经添加好group_3通过Migrate Slot(s)选项，我们来迁移group_1组到group_3组：为了模拟迁移是否会影响到业务，我在一台机器开启插入数据脚本，[root@vmware-132 scripts]# sh redis-key.sh \\脚本里面连接codis群集请修改为虚拟IP.现在又客户端在实时插入数据，接下来通过管理界面操作步骤如下： 目前客户端在不断插入新数据，后端我们又在迁移组数据，那么我们现在在来get数据看看是否正常。 12345678910[root@vmware-130 ~]# redis-cli -h 192.168.43.100 -p 45001192.168.43.100:45001&gt; get abc\"123\"192.168.43.100:45001&gt; get benet\"lwz\"192.168.43.100:45001&gt; get mike\"liweizhong\"192.168.43.100:45001&gt; get id\"27\"192.168.43.100:45001&gt; exit 可以看到后端在迁移数据，对业务访问不受影响。这点非常赞。迁移完成后，如下图所示： 4.模拟codis-proxy节点挂掉，看haproxy服务是否会剔除节点。我们仍继续用脚本插入数据，然后停止vmware-131上面的codis-proxy服务。1[root@vmware-132 scripts]# sh redis-key.sh 123456789[root@vmware-130 ~]# redis-cli -h 192.168.43.100 -p 45001192.168.43.100:45001&gt; get mike\"liweizhong\"192.168.43.100:45001&gt; get benet\"lwz\"192.168.43.100:45001&gt; get id\"27\"192.168.43.100:45001&gt; get abc\"123\" codis-proxy代理节点挂掉一个，haproxy自动剔除此节点，插入数据脚本由于之前连接的socket挂掉，会中断重新连接新的socket. 业务正常访问，以下为haproxy监控页面信息： codis管理界面我们可以看到codis_proxy_2已经没有显示出来： 当codis_proxy_2恢复的时候，haproxy又自动加入此节点，并正常提供服务。 codis管理界面又正常显示codis_proxy_2节点。 5.keepalived+haproxy群集故障测试一、停止haproxy-master , 观察/var/log/message日志照样启动redis-key.sh插入数据脚本 12[root@vmware-132 scripts]# sh redis-key.sh 停止 haproxy master 以下为截取到的日志信息:keepalived master 130 tail -f /var/log/message 插入数据脚本会出现中断，然后又正常插入数据。虚拟IP出现一次掉包，然后马上恢复了。 二、恢复haproxy-master, 观察/var/log/message日志，看是否被抢占，正常情况主haproxy恢复后，不会进行切换，防止业务来回切换。。。接下来我们恢复haproxy-master 123[root@vmware-130 logs]# service haproxy startStarting haproxy: [ OK ]tail -f /var/log/message 以上截图我们可以看到恢复haproxy-master后，VIP不会进行漂移，keepalived进入BACKUP状态，这是因为设置了nopreempt参数，不抢占，防止业务来回切换。。。 三、停止haproxy-backup, 观察 /var/log/message日志，是否进行切换。以上我们模拟了haproxy-master故障和恢复，现在我们再次模拟现在的haproxy-master也就是原先的haproxy-backup.模拟haproxy-backup进程挂掉： keepalived master 130 tail -f /var/log/message keepalived backup 132 tail -f /var/log/messageVIP进行了漂移，keepalived也切换身份。再次恢复haproxy-backup ,VIP不进行漂移，与以上类似，不在描述。 四、模拟keepalived进程挂掉 keepalived-master挂掉，keepalived主备切换，VIP进行漂移。当keepalived-master恢复时，直接进入BACKUP状态，不进行主备切换，VIP不漂移。 »至此已经完成。","categories":[{"name":"Codis","slug":"Codis","permalink":"/categories/Codis/"}],"tags":[{"name":"集群","slug":"集群","permalink":"/tags/集群/"},{"name":"负载","slug":"负载","permalink":"/tags/负载/"},{"name":"Codis","slug":"Codis","permalink":"/tags/Codis/"}],"keywords":[{"name":"Codis","slug":"Codis","permalink":"/categories/Codis/"}]},{"title":"Codis 高可用负载均衡群集的搭建与使用","slug":"Codis01","date":"2016-11-03T09:41:52.559Z","updated":"2016-11-03T09:41:52.559Z","comments":true,"path":"2016/11/03/Codis01/","link":"","permalink":"/2016/11/03/Codis01/","excerpt":"codis-proxy 提供连接集群redis服务的入口 codis-redis-group 实现vredis`读写的水平扩展，高性能 codis-redis 实现redis实例服务，通过codis-ha实现服务的高可用 一、实验环境：网络拓扑图:","text":"codis-proxy 提供连接集群redis服务的入口 codis-redis-group 实现vredis`读写的水平扩展，高性能 codis-redis 实现redis实例服务，通过codis-ha实现服务的高可用 一、实验环境：网络拓扑图: 群集架构图: 机器与应用列表 操作系统：System version: CentOS 6.7 IP: 192.168.43.130 hostname: vmware-130 apps: keepalived + haproxy Master, zookeeper_1, codis_proxy_1, codis_config, codis_server_master,slave IP: 192.168.43.131 hostname: vmware-131 apps: zookeeper_2, codis_proxy_2, codis_server_master,slave IP: 192.168.43.132 hostname: vmware-132 apps: keepalived + haproxy Backup, zookeeper_3, codis_proxy_3, codis_server_master,slave VIP: 192.168.43.100 Port: 45001 备注：由于是虚拟测试环境，非生产环境，所以一台机器跑多个应用，如应用于生产环境，只需把应用分开部署到相应机器上即可。 1、初始化CentOS系统 使用镜像站点配置好的yum安装源配置文件 123cd /etc/yum.repos.d//bin/mv CentOS-Base.repo CentOS-Base.repo.bakwget http://mirrors.163.com/.help/CentOS6-Base-163.repo 接下来执行如下命令，检测yum是否正常 12yum clean all #清空yum缓存yum makecache #建立yum缓存 然后使用如下命令将系统更新到最新 12rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY* #导入签名KEY到RPMyum upgrade -y 2. 关闭不必要的服务1234for sun in `chkconfig --list|grep 3:on|awk '&#123;print $1&#125;'`;do chkconfig --level 3 $sun off;donefor sun in `chkconfig --list|grep 5:on|awk '&#123;print $1&#125;'`;do chkconfig --level 5 $sun off;donefor sun in crond rsyslog sshd network;do chkconfig --level 3 $sun on;donefor sun in crond rsyslog sshd network;do chkconfig --level 5 $sun on;done 3. 安装依赖包1yum install -y gcc make gcc-c++ automake lrzsz openssl-devel zlib-* bzip2-* readline* zlib-* bzip2-* 4. 创建软件存放目录1mkdir /data/packages 5. 软件包版本以及下载地址123456789101112jdk1.8.0_45zookeeper-3.4.8go1.6.2pcre-8.37haproxy-1.4.22keepalived-1.4.26cd /data/packageswget http://apache.fayea.com/zookeeper/zookeeper-3.4.6/zookeeper-3.4.6.tar.gzwget http://golangtc.com/static/go/go1.6.2.linux-amd64.tar.gzwget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.37.tar.gzwget http://www.keepalived.org/software/keepalived-1.2.16.tar.gz 通过浏览器自行下载 http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.htmlhttp://www.haproxy.org/download/1.4/src/haproxy-1.4.26.tar.gz 6. 重启系统1[root@vmware-130 ~]# init 6 二、部署Zookeeper群集 配置hosts文件 ( zookeeper节点机器上配置 ) 1234[root@vmware-130 ~]# vim /etc/hosts192.168.43.130 vmware-130192.168.43.131 vmware-131192.168.43.132 vmware-132 安装java 坏境 ( zookeeper节点机器上配置 ) 1234[root@vmware-130 ~]# cd /data/packages[root@vmware-130 packages ]# tar zxvf jdk-8u45-linux-x64.tar.gz -C /usr/local[root@vmware-130 packages ]# cd /usr/local[root@vmware-130 local ]# ln -s jdk1.8.0_45 java 安装Zookeeper ( zookeeper节点机器上配置 ) 1234cd /data/packagestar zxvf zookeeper-3.4.6.tar.gz -C /usr/localln -s zookeeper-3.4.6 zookeepercd /usr/local/zookeeper/ 设置环境变量 ( zookeeper节点机器上配置 ) 1234567891011vim /etc/profileJAVA_HOME=/usr/local/javaJRE_HOME=$JAVA_HOME/jreZOOKEEPER_HOME=/usr/local/zookeeperJAVA_FONTS=/usr/local/java/jdk1.8.0_102/jre/lib/fonts CLASSPATH=$JAVA_HOME/lib:$JAVA_HOME/lib/tools.jarPATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$ZOOKEEPER_HOME/bin export JAVA_HOME PATH CLASSPATH JRE_HOME ZOOKEEPER_HOME#生效环境变量source /etc/profile 修改zookeeper配置文件 ( zookeeper节点机器上配置 ) 1234567891011121314vi /usr/local/zookeeper/conf/zoo.cfgtickTime=2000initLimit=10syncLimit=5clientPort=2181autopurge.snapRetainCount=500 autopurge.purgeInterval=24dataDir=/data/zookeeper/datadataLogDir=/data/zookeeper/logsserver.1=192.168.43.130:2888:3888server.2=192.168.43.131:2888:3888server.3=192.168.43.132:2888:3888#生效环境变量source /etc/profile 创建数据目录和日志目录 ( zookeeper节点机器上配置 ) 12mkdir -p /data/zookeeper/datamkdir -p /data/zookeeper/logs 在zookeeper节点机器上创建myid文件，节点对应id在43.130机器上创建myid，并设置为1与配置文件zoo.cfg里面server.1对应。 1echo \"1\" &gt; /data/zookeeper/data/myid 在zookeeper节点机器上创建myid文件，节点对应id 在43.131机器上创建myid，并设置为1与配置文件zoo.cfg里面server.2对应。 1echo \"2\" &gt; /data/zookeeper/data/myid 在zookeeper节点机器上创建myid文件，节点对应id在43.132机器上创建myid，并设置为1与配置文件zoo.cfg里面server.3对应。 1echo \"3\" &gt; /data/zookeeper/data/myid 启动zookeeper服务, 以vmware-130为例： 1234[root@vmware-130 ~]# zkServer.sh startJMX enabled by defaultUsing config: /usr/local/zookeeper/bin/../conf/zoo.cfgStarting zookeeper ... STARTED 检查zookeeper所有节点状态 1234567891011121314[root@vmware-130 ~]# zkServer.sh statusJMX enabled by defaultUsing config: /usr/local/zookeeper/bin/../conf/zoo.cfgMode: follower [root@vmware-131 ~]# zkServer.sh statusJMX enabled by defaultUsing config: /usr/local/zookeeper/bin/../conf/zoo.cfgMode: follower [root@vmware-132 ~]# zkServer.sh statusJMX enabled by defaultUsing config: /usr/local/zookeeper/bin/../conf/zoo.cfgMode: leader 三、部署Codis群集 安装go语言环境 ( 所有codis机器上配置 ) 12/data/packagestar zxvf go1.4.2.linux-amd64.tar.gz -C /usr/local 添加GO环境变量，其他环境变量不变 1234567vim /etc/profileGOROOT=/usr/local/goGOPATH=/usr/local/codisPATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$ZOOKEEPER_HOME/bin:$GOROOT/binexport JAVA_HOME PATH CLASSPATH JRE_HOME ZOOKEEPER_HOME GOROOT GOPATHsource /etc/profile 安装codis ( 所有codis机器上配置 ) 12345678910111213yum install -y gitgo get -u -d github.com/CodisLabs/codiscd $GOPATH/src/github.com/CodisLabs/codis#执行编译测试脚本，编译go和reids。 makemake gotest# 将编译好后，把bin目录和一些脚本复制过去/usr/local/codis目录下：mkdir -p /usr/local/codis/&#123;logs,conf,scripts&#125; #创建codis日志，配置文件，脚本目录mkdir -p /data/codis_server/&#123;logs,conf,data&#125; #创建codis_server 日志，配置文件，数据目录cp -rf /usr/local/codis/src/github.com/CodisLabs/codis/bin /usr/local/codis/ #复制bin目录到自定义的安装目录cp /usr/local/codis/src/github.com/CodisLabs/codis/config.ini /usr/local/codis/conf/ #复制模板配置文件到安装目录cp /usr/local/codis/src/github.com/CodisLabs/codis/sample/redis_conf/6381.conf /data/codis_server/conf/ #复制codis_server配置文件到配置目录cp -rf /usr/local/codis/src/github.com/CodisLabs/codis/sample/usage.md /usr/local/codis/scripts/ #复制模板启动流程文件到脚本目录下 配置codis_proxy_1 (vmware-130 机器上配置) 12345678cd /usr/local/codisvim config.ini zk=vmware-130:2181,vmware-131:2181,vmware-132:2181 product=codis proxy_id=codis_proxy_1 net_timeout=5dashboard_addr=192.168.43.130:18087 coordinator=zookeeper 配置codis_proxy_1 (vmware-131 机器上配置) 12345678cd /usr/local/codisvim config.ini zk=vmware-130:2181,vmware-131:2181,vmware-132:2181 product=codis proxy_id=codis_proxy_2 net_timeout=5dashboard_addr=192.168.43.130:18087 coordinator=zookeeper 配置codis_proxy_1 (vmware-132 机器上配置) 12345678cd /usr/local/codisvim config.ini zk=vmware-130:2181,vmware-131:2181,vmware-132:2181 product=codis proxy_id=codis_proxy_3 net_timeout=5dashboard_addr=192.168.43.130:18087 coordinator=zookeeper 修改配置文件，启动codis-server服务. ( 所有codis-server机器上 ) 12345678910111213cd /data/codis_server/conf/mv 6381.conf 6379.confvim 6379.conf修改如下参数: (生产环境，参数适当进行调整)daemonize yespidfile /var/run/redis_6379.pidport 6379logfile \"/data/codis_server/logs/codis_6379.log\"save 900 1save 300 10save 60 10000dbfilename 6379.rdbdir /data/codis_server/data 复制6380配置文件 12cp 6379.conf 6380.confsed -i 's/6379/6380/g' 6380.conf 添加内核参数 12echo \"vm.overcommit_memory = 1\" &gt;&gt; /etc/sysctl.confsysctl -p 启动codis-server服务 ( 所有codis-server机器上 ) 12/usr/local/codis/bin/codis-server /data/codis_server/conf/6379.conf/usr/local/codis/bin/codis-server /data/codis_server/conf/6380.conf 查看一下启动流程：( 以vmware-130机器为例 ) 12345678910[root@vmware-130 ~]# cat /usr/local/codis/scripts/usage.md0. start zookeeper //启动zookeeper服务1. change config items in config.ini //修改codis配置文件2. ./start_dashboard.sh //启动 dashboard3. ./start_redis.sh //启动redis实例4. ./add_group.sh //添加redis组，一个redis组只能有一个master5. ./initslot.sh //初始化槽6. ./start_proxy.sh //启动codis_proxy7. ./set_proxy_online.sh //上线proxy项目8. open browser to http://localhost:18087/admin //访问管理界面 这只是一个参考，有些顺序不是必须的，但启动dashboard前，必须启动zookeeper服务，这是必须的，后面有很多操作，都可以在管理页面完成，例如添加/删除组、数据分片、添加/删除redis实例等 创建dashboard启动脚本。可参考/usr/local/codis/src/github.com/wandoulabs/codis/sample/模板脚本( 只需在一台机器上启动即可。43.130上启动 ) 1234[root@vmware-130 ~]# vim /usr/local/codis/scripts/start_dashboard.sh#!/bin/shCODIS_HOME=/usr/local/codis nohup $CODIS_HOME/bin/codis-config -c $CODIS_HOME/conf/config.ini -L $CODIS_HOME/logs/dashboard.log dashboard --addr=:18087 --http-log=$CODIS_HOME/logs/requests.log &amp;&gt;/dev/null &amp; 启动dashboard 12[root@vmware-130 ~]# cd /usr/local/codis/scripts/[root@vmware-130 scripts ]# sh start_dashboard.sh 创建初始化槽脚本，可参考/usr/local/codis/src/github.com/wandoulabs/codis/sample/模板脚本( 在任一台机器上机器上配置，此环境在43.130机器上配置 ) 123456[root@vmware-130 ~]# vim /usr/local/codis/scripts/initslot.sh#!/bin/shCODIS_HOME=/usr/local/codisecho \"slots initializing...\"$CODIS_HOME/bin/codis-config -c $CODIS_HOME/conf/config.ini slot init -fecho \"done\" 执行初始化槽脚本： 12[root@vmware-130 ~]# cd /usr/local/codis/scripts[root@vmware-130 scripts ]# sh initslot.sh 配置codis-server,启动codis-server master ,slave实例 ，以上步骤已经启动，不在描述。 通过管理页面添加组ID，为组添加主从实例，一个组里只能有一个master，设置slot分片数据等。 http://192.168.43.130:18087（最好用Firefox浏览器或者谷歌浏览器，别的浏览器比较坑爹！！！）如下图所示： 接下来，依次添加 Server Group 1,2,3 ( 共添加3组 ) 添加好后，图为下: 接下来添加codis-server实例包括master,slave 全部添加完成后，如下图所示： 为组分配Slot(槽)范围 123group_1 0 - 511group_2 512 - 1023group_3 暂时不分配，以下测试中，用来迁移其他组使用。 如下图操作所示：group_1 ( 0 - 511 ) 添加成功后，页面会显示success窗口，如下图所示。 如下图操作所示：group_2 ( 512 - 1023 ) 添加成功后，页面会显示success窗口，如下图所示。 查看整个Slots分布情况: 选择 Slots Status 或者 右上角那个 Slots 都可以看到分布情况。 配置codis-ha服务，主从自动切换。( 随便找个节点机器上配置即可,此环境中在43.131机器上配置 ) 12345[root@vmware-131 ~]# go get github.com/ngaut/codis-ha[root@vmware-131 ~]# cd /usr/local/codis/src/github.com/ngaut[root@vmware-131 ~]# cp -r codis-ha /usr/local/[root@vmware-131 ~]# cd /usr/local/codis-ha[root@vmware-131 codis-ha ]# go build 创建启动脚本，启动codis-ha服务 123[root@vmware-131 ~]# vim /usr/local/codis-ha/start_codis_ha.sh#!/bin/sh./codis-ha --codis-config=192.168.43.130:18087 -log-level=\"info\" --productName=vmware-Codis &amp;&gt; ./logs/codis-ha.log &amp; 创建日志目录 123[root@vmware-131 ~]# mkdir /usr/local/codis-ha/logs[root@vmware-131 ~]# cd /usr/local/codis-ha/[root@vmware-131 codis-ha ]# sh start_codis_ha.sh 修改start_proxy.sh，启动codis-proxy服务 ( 以130机器配置为例，其余codis-proxy只需修改下名称即可。) 1234567891011121314151617181920212223[root@vmware-130 scripts]# vim /usr/local/codis/scripts/start_proxy.sh #!/bin/shCODIS_HOME=/usr/local/codisecho \"shut down codis_proxy_1...\"$CODIS_HOME/bin/codis-config -c $CODIS_HOME/conf/config.ini proxy offline codis_proxy_1echo \"done\"echo \"start new codis_proxy_1...\"nohup $CODIS_HOME/bin/codis-proxy --log-level error -c $CODIS_HOME/conf/config.ini -L $CODIS_HOME/logs/codis_proxy_1.log --cpu=8 --addr=0.0.0.0:19000 --http-addr=0.0.0.0:11000 &amp;echo \"done\"echo \"sleep 3s\"sleep 3tail -n 30 $CODIS_HOME/logs/codis_proxy_1.log[root@vmware-130 scripts]# vim /usr/local/codis/scripts/set_proxy_online.sh #!/bin/shCODIS_HOME=/usr/local/codisecho \"set codis_proxy_1 online\"$CODIS_HOME/bin/codis-config -c $CODIS_HOME/conf/config.ini proxy online codis_proxy_1echo \"done\"启动codis-proxy./start_proxy.sh上线codis_proxy_1./set_proxy_online.sh备注：其他codis_proxy只需修改start_proxy.sh和set_proxy_online.sh启动脚本里面的codis_proxy_1名称即可。 通过redis-cli客户端直接访问codis-proxy,写入数据，看组里面的master和slave 是否同步。 1234567[root@vmware-130 scripts]# redis-cli -p 19000127.0.0.1:19000&gt; set mike liweizhongOK127.0.0.1:19000&gt; set benet lwzOK127.0.0.1:19000&gt; exit[root@vmware-130 scripts]# 通过管理界面看到如下图所示： codis-server master,slave 同步数据正常，slots槽分片数据正常 接下来在通过codis-proxy去取数据看看 1234567[root@vmware-130 scripts]# redis-cli -p 19000127.0.0.1:19000&gt; get mike\"liweizhong\"127.0.0.1:19000&gt; get benet\"lwz\"127.0.0.1:19000&gt; exit[root@vmware-130 scripts]# 以下用shell简单的写了个插入redis数据脚本，此脚本会插入20W个key,每运行一次，需要调整INSTANCE_NAME参数里面的数字，才可重新插入新数据。仅供测试使用： 123456789101112131415[root@vmware-132 scripts]# cat redis-key.sh #!/bin/bashREDISCLI=\"redis-cli -h 192.168.43.131 -p 19000 -n 0 SET\"ID=1while [ $ID -le 50000 ]do INSTANCE_NAME=\"i-2-$ID-VM\" UUID=`cat /proc/sys/kernel/random/uuid` CREATED=`date \"+%Y-%m-%d %H:%M:%S\"` $REDISCLI vm_instance:$ID:instance_name \"$INSTANCE_NAME\" $REDISCLI vm_instance:$ID:uuid \"$UUID\" $REDISCLI vm_instance:$ID:created \"$CREATED\" $REDISCLI vm_instance:$INSTANCE_NAME:id \"$ID\"ID=`expr $ID + 1`done 执行插入脚本 1[root@vmware-132 scripts]# sh redis-key.sh 通过管理界面，我们可以看到如下图所示 数据插完后，最终如下图所示 »第三部分部，署Keepalived + haproxy 高可用负载均衡请看下一节，至此第一、二部分已经完成。","categories":[{"name":"Codis","slug":"Codis","permalink":"/categories/Codis/"}],"tags":[{"name":"集群","slug":"集群","permalink":"/tags/集群/"},{"name":"负载","slug":"负载","permalink":"/tags/负载/"},{"name":"Codis","slug":"Codis","permalink":"/tags/Codis/"}],"keywords":[{"name":"Codis","slug":"Codis","permalink":"/categories/Codis/"}]},{"title":"我和python的第一次接触","slug":"python01","date":"2016-11-03T07:29:07.497Z","updated":"2016-11-03T07:29:07.497Z","comments":true,"path":"2016/11/03/python01/","link":"","permalink":"/2016/11/03/python01/","excerpt":"Python诞生Python是著名的’龟叔Guido van Rossum(吉多·范罗苏在1989年圣诞节期间，为了打发无聊的圣诞节而编写的一个编程语言。","text":"Python诞生Python是著名的’龟叔Guido van Rossum(吉多·范罗苏在1989年圣诞节期间，为了打发无聊的圣诞节而编写的一个编程语言。 Python语法很多来自C，但又受到ABC语言的强烈影响。来自ABC语言的一些规定直到今天还富有争议比如强制缩进。但这些语法规定让Python容易读。Guido van Rossum著名的一句话就是Life is short, you need Python，译为：人生苦短，我用Python. 截至到目前2016年4月28日，Python在Tiobe的排名还是很靠前的，而且近几年来说Python上升的趋势已经超过PHP紧随C#。查询网站：http://www.tiobe.com/tiobe_index?page=index Python实现方式Python身为一门编程语言，但是他是有多种实现方式的，这里的实现指的是符合Python语言规范的Python解释程序以及标准库等。 Python的实现方式主要分为三大类 Cpython PyPy Jpython、IronPython等等类似的实现方式 CPython 当Python执行代码的时候，会启用一个Python解释器，将源码(.py)文件读取到内存当中，然后编译成字节码(.pyc)文件，最后交给Python的虚拟机逐行解释并执行其内容，然后释放内存，退出程序。 当第二次在执行当前程序的时候，会现在当前目录下寻找有没有同名的pyc文件，如果找到了，则直接进行运行，否则重复上面的工作。 pyc文件的目的其实就是为了实现代码的重用，为什么这么说呢？因为Python认为只要是import导入过来的文件，就是可以被重用的，那么他就会将这个文件编译成pyc文件。 python会在每次载入模块之前都会先检查一下py文件和pyc文件的最后修改日期，如果不一致则重新生成一份pyc文件，否则就直接读取运行。 PyPy Python（RPython Python）的Python实现版本，原理是这样的，PyPy运行在CPython（或者其它实现）之上，用户程序运行在PyPy之上。它的一个目标是成为Python语言自身的试验场，因为可以很容易地修改PyPy解释器的实现（因为它是使用Python写的），PyPy的代码性能是Cpython的五倍以上。 性能对比图 Jythonython是个Python的一种实现方式，Jython编译Python代码为Java字节码，然后由JVM（Java虚拟机）执行，这意味着此时Python程序与Java程序没有区别，只是源代码不一样。此外，它能够导入和使用任何Java类像Python模块。 IronPythonIronPython是Python的C#实现，并且它将Python代码编译成C#中间代码（与Jython类似），然后运行，它与.NET语言的互操作性也非常好。 安装PythonWindows安装Python2.7.11 下载Python软件64位下载地址：https://www.python.org/ftp/python/2.7.11/python-2.7.11.amd64.msi32位下载地址：https://www.python.org/ftp/python/2.7.11/python-2.7.11.msi 安装Python软件下载下来之后双击安装，安装时一路下一步下一步即可，默认的安装路径是：C:\\Python27 配置环境变量右键计算机 —&gt; 属性 —&gt; 高级系统设置 —&gt; 高级 —&gt; 环境变量 —&gt;在第二个内容框中找到变量名为Path的一行，双击 —&gt; Python安装目录追加到变值值中，用;分割如图： 如：原来的值``;C:\\python27，切记前面有分号,Windows 10安装后默认会把环境变量配置好。 cmd测试win+r调出运行窗口，然后输入cmd 在cmd窗口中输入python指令 如果你得到的结果和我一样，那么你就安装好了windows下的python环境 CentOS升级到Python2.7.11CentOS6.7默认自带Python2.6.6版本，如果你不需要升级到2.7.11请跳过这段，如果需要升级请继续往下看 下载python2.7.11源码包下载地址：https://www.python.org/ftp/python/2.7.11/Python-2.7.11.tgz 安装开发工具包 1# yum -y groupinstall \"debugging Tools\" 编译安装 1234# tar xf Python-2.7.11.tgz# cd Python-2.7.11# ./configure -prefix=/usr/local/python2.7.11# make &amp;&amp; # make install 更改配置创建链接来使系统默认python变为python2.7 1# ln -fs /usr/local/python2.7.11/bin/python2.7 查看Python版本 12# python -VPython 2.7.11 修改yum配置（否则yum无法正常运行） 1234# vim /usr/bin/yum# !/usr/bin/python# 将第一行改为# !/usr/bin/python2.6 Python简单入门Hello Word一般情况下程序猿的第一个小程序都是简单的输出Hello Word!，当然Python也不例外，下面就让我们来用Python输出一句Hello Word!吧！ 创建一个以py结尾的文件 1# touch hello.py 其内容为 12#!/usr/vin/env pythonprint \"Hello Word!\" 用Python执行 12# python hello.pyHello Word! 输出的内容为Hello Word!，OK Python代码执行流程释意：当Python执行代码的时候，会先把源码读取到内存当中，然后由Cpython进行编译，编译成字节码，最后由Cpython的虚拟机一行一行的解释其内容，再输出到屏幕上，然后释放内存，退出程序。 pyc文件执行Python代码时，如果导入了其他的.py文件，那么，执行过程中会自动生成一个与其同名的.pyc文件，该文件就是Python解释器编译之后产生的字节码。代码经过编译可以产生字节码；字节码通过反编译也可以得到代码 指定Python解释器在Python文件的开头加入以下代码就制定了解释器。 第一种方式 1#!/usr/bin/python 告诉shell这个脚本用/usr/bin/python执行 第二种方式 1#!/usr/bin/env python 在操作系统环境不同的情况下制定这个脚本用python来解释。 执行Python文件执行Python文件的方式有两种 例如hello.py的文件内容为 12#!/usr/bin/env pythonprint \"Life is short, you need Pytho\" 第一种执行方式 12# python my.pyLife is short, you need Pytho 如果使用python my.py这种方式执行，那么#!/usr/bin/python会被忽略，等同于注释。 第二种执行方式 123# chmod +x my.py # ./my.py Life is short, you need Pytho 如果使用./my.py来执行，那么#!/usr/bin/python则是指定解释器的路径，在执行之前my.py这个文件必须有执行权限。 python my.py实则就是在my.py文件顶行加入了#!/usr/bin/python 字符编码python解释器在加载.py文件中的代码时，会对内容进行编码，python2.7内部默认ascii字符，而最新的python3.5默认使用UTF-8。ascii字符(26个字母，8位表示所有，字符，英文 数字 )万国码(unicode，最少两个字节，所有的字符，一个中文汉字3个字节表示，占用字节多，浪费空间)UTF-8（unicode：英文特殊字符用八位表示，中文–24位….,解决unicode所占用的内存） 指定字符编码python制定字符编码的方式有多种，而编码格式是要写在解释器的下面的，常用的如下面三种: 第一种 12#!/usr/bin/env python# _*_ coding:utf-8 _*_ 第二种 12#!/usr/bin/env python# -*- coding:utf-8 -*- 第三种 12#!/usr/bin/env python# coding:utf-8 代码注释单行注释1# 注释内容 多行注释多行注释用三个单引号或者三个双引号躲起来 单行注释只需要在代码前面加上#号 123\"\"\"注释内容\"\"\" 实例py脚本原文件内容 123456#!/usr/bin/env python# _*_ coding:utf-8 _*_print \"My name isAlexzhou\"print \"I'm a Python developer\"print \"My blog URL: http://msbgn.cn\"print \"Life is short, you need Pytho\" 源文件输出的内容12345# python my.py My name is AlexzhouI'm a Python developerMy blog URL: http://www.msbgn.cnLife is short, you need Pytho 单行注释演示 代码改为 123456#!/usr/bin/env python# _*_ coding:utf-8 _*_print \"My name is Alexzhou\"print \"I'm a Python developer\"print \"My blog URL: http://www.msbgn.cn\"#print \"Life is short, you need Pytho\" 执行结果 1234# python my.py My name is AlexzhouI'm a Python developerMy blog URL: http://www.msbgn.cn 结果Life is short, you need Pythoprint出来 多行注释演示 代码改为 1234567#!/usr/bin/env python# _*_ coding:utf-8 _*_print \"My name is Alexzhou\"\"\"\"print \"I'm a Python developer\"print \"Life is short, you need Pytho\"\"\"\" 执行结果 12# python my.py My name is Alexzhou print输出多行既然用单个单引号或者多引号可以注释多行，那么能不能print多行呢？ 代码 12345678#!/usr/bin/env python# _*_ coding:utf-8 _*_print \"\"\"My name is AlexzhouI'm a Python developerMy blog URL: http://www.msbgn.cnLife is short, you need Python.\"\"\" 执行结果123456# python my.py My name is AlexzhouI'm a Python developerMy blog URL: http://www.msbgn.cnLife is short, you need Python. 变量 1.变量名只能包含数字、字幕、下划线2.不能以数字开头3.变量名不能使python内部的关键字 Python内部已占用的关键字[‘and’, ‘as’, ‘assert’, ‘break’, ‘class’, ‘continue’, ‘def’, ‘del’, ‘elif’, ‘else’, ‘except’, ‘exec’, ‘finally’, ‘for’, ‘from’, ‘g] 定义变量 123&gt;&gt;&gt; name = \"Alexzhou\" &gt;&gt;&gt; print nameAlexzhou 基本的数据类型 字符串(str)定义字符串类型是需要用单引号或者双引号包起来的 123&gt;&gt;&gt; name = \"Alexzhou\"&gt;&gt;&gt; print(type(name))&lt;type 'str'&gt; 或者 123&gt;&gt;&gt; name = 'Alexzhou'&gt;&gt;&gt; print(type(name))&lt;type 'str'&gt; 数字(int)证书类型定义的时候变量名后面可以直接跟数字，不要用双引号包起来。 123&gt;&gt;&gt; age = 20&gt;&gt;&gt; print(type(age))&lt;type 'int'&gt; 布尔值()布尔值就只有True(真)，Flash(假) 123456&gt;&gt;&gt; if True:... print(\"0\")... else:... print(\"1\")...0 解释：如果为真则输出0，否则输出1 流程控制if语句if语句是用来检查一个条件：如果条件为真(true)，我们运行一个语句块（你为if块），否则(else)，我们执行另一个语句块（称为else块）。else子语句是可选的。 单条件例题：如果num变量大于1，那么就输出num大，否则就输出num小，num值为5。 代码 1234567#!/usr/bin/env python# -*- coding:utf-8 -*-num = 5if num &gt; 1: print(\"num大\")else: print(\"num小\") 结果12# python num.pynum大 多条件例题：如果num变量大于5，那么就输出num大于5，如果num变量小于5，那么就输出num小于5，否则就输出num等于5，num值为5。123456789#!/usr/bin/env python# -*- coding:utf-8 -*-num = 5if num &gt; 5: print(\"num大于5\")elif num &lt; 5: print(\"num小于5\")else: print(\"num等于5\") 结果12python num.pynum等于5 » python基础教程分享百度云盘链接: https://pan.baidu.com/s/1eSyXdx4 密码: 3ehk» 文章出自链接：https://blog.ansheng.me/2016/04/python-full-stack-way-basics.html","categories":[{"name":"python","slug":"python","permalink":"/categories/python/"}],"tags":[{"name":"语言","slug":"语言","permalink":"/tags/语言/"},{"name":"python","slug":"python","permalink":"/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"/categories/python/"}]},{"title":"zabbix邮件报警设置","slug":"Zabbixmail","date":"2016-11-02T08:55:13.457Z","updated":"2016-11-02T08:55:13.457Z","comments":true,"path":"2016/11/02/Zabbixmail/","link":"","permalink":"/2016/11/02/Zabbixmail/","excerpt":"邮件报警有两种情况：1、Zabbix服务端只是单纯的发送报警邮件到指定邮箱，发送报警邮件的这个邮箱账号是Zabbix服务端的本地邮箱账号（例如：root@localhost)2、使用一个可以在互联网上正常收发邮件的邮箱账号（例如：xxx@163.com），通过在Zabbix服务端中设置，使其能够发送报警邮件到指定邮箱。（这里我们使用第二种）","text":"邮件报警有两种情况：1、Zabbix服务端只是单纯的发送报警邮件到指定邮箱，发送报警邮件的这个邮箱账号是Zabbix服务端的本地邮箱账号（例如：root@localhost)2、使用一个可以在互联网上正常收发邮件的邮箱账号（例如：xxx@163.com），通过在Zabbix服务端中设置，使其能够发送报警邮件到指定邮箱。（这里我们使用第二种） 1、使用外部邮箱账号发送报警邮件设置一、关闭sendmail或者postfix12345678service sendmail stop #关闭chkconfig sendmail off #禁止开机启动service postfix stopchkconfig postfix off备注：使用外部邮箱账号时，不需要启动sendmail或者postfix如果在sendmail或者postfix启动的同时使用外部邮箱发送报警邮件，首先会读取外部邮箱配置信息。 二、安装邮件发送工具mailx 1yum install mailx #安装 CentOS 5.x 编译安装mailx，直接yum安装的mailx版本太旧，使用外部邮件发送会有问题。 1yum remove mailx #卸载系统自带的旧版mailx 下载mailx：http://nchc.dl.sourceforge.net/project/heirloom/heirloom-mailx/12.4/mailx-12.4.tar.bz2 12345678tar jxvf mailx-12.4.tar.bz2 #解压cd mailx-12.4 #进入目录make #编译make install UCBINSTALL=/usr/bin/install #安装ln -s /usr/local/bin/mailx /bin/mail #创建mailx到mail的软连接ln -s /etc/nail.rc /etc/mail.rc #创建mailx配置文件软连接whereis mailx #查看安装路径mailx -V #查看版本信息 三、配置Zabbix服务端外部邮箱12345678vi /etc/mail.rc #编辑，添加以下信息set from=xxx@163.com smtp=smtp.163.comset smtp-auth-user=xxx@163.com smtp-auth-password=123456set smtp-auth=login:wq! #保存退出echo \"zabbix test mail\" |mail -s \"zabbix\" yyy@163.com#测试发送邮件，标题zabbix，邮件内容：zabbix test mail，发送到的邮箱：yyy@163.com#这时候，邮箱yyy@163.com会收到来自xxx@163.com的测试邮件 四、配置Zabbix服务端邮件报警 1、打开Zabbix管理-示警媒介类型-Email1234567名称：Email类型：电子邮件SMTP伺服器：zabbix.sa.huanqiu.comSMTP HELO：zabbix.sa.huanqiu.comSMTP电邮：zabbix@zabbix.sa.huanqiu.com已经用：勾选存档 2、设置Zabbix用户报警邮箱地址组态-用户-Admin (Zabbix Administrator)切换到示警媒介-添加12345类型：Email收件人：xxx@163.com其他默认即可，也可以根据需要设置状态：已启用存档 3、设置Zabbix触发报警的动作 组态-动作-创建动作1234567891011121314151617181920212223名称：Action-Email默认接收人：故障&#123;TRIGGER.STATUS&#125;,服务器:&#123;Zabbix server&#125;发生: &#123;TRIGGER.NAME&#125;故障!默认信息：告警主机:&#123;Zabbix server&#125;告警时间:&#123;EVENT.DATE&#125; &#123;EVENT.TIME&#125;告警等级:&#123;TRIGGER.SEVERITY&#125;告警信息: &#123;TRIGGER.NAME&#125;告警项目:&#123;TRIGGER.KEY1&#125;问题详情:&#123;ITEM.NAME&#125;:&#123;ITEM.VALUE&#125;当前状态:&#123;TRIGGER.STATUS&#125;:&#123;ITEM.VALUE1&#125;事件ID:&#123;EVENT.ID&#125;恢复信息：打钩恢复主旨：恢复&#123;TRIGGER.STATUS&#125;, 服务器:&#123;Zabbix server&#125;: &#123;TRIGGER.NAME&#125;已恢复!恢复信息：告警主机:&#123;Zabbix server&#125;告警时间:&#123;EVENT.DATE&#125; &#123;EVENT.TIME&#125;告警等级:&#123;TRIGGER.SEVERITY&#125;告警信息: &#123;TRIGGER.NAME&#125;告警项目:&#123;TRIGGER.KEY1&#125;问题详情:&#123;ITEM.NAME&#125;:&#123;ITEM.VALUE&#125;当前状态:&#123;TRIGGER.STATUS&#125;:&#123;ITEM.VALUE1&#125;事件ID:&#123;EVENT.ID&#125;已启用：打钩 切换到操作选项新的 123操作类型：送出信息送到用户：添加默认信息：打钩 12用户：勾选Admin选择 仅送到：Email存档 4、添加Zabbix服务端邮件发送脚本123456789cd /usr/local/zabbix/share/zabbix/alertscripts #进入脚本存放目录vi sendmail.sh #编辑，添加以下代码#!/bin/shecho \"$3\" | mail -s \"$2\" $1:wq! #保存退出chown zabbix.zabbix /usr/local/zabbix/share/zabbix/alertscripts/sendmail.sh#设置脚本所有者为zabbix用户chmod +x /usr/local/zabbix/share/zabbix/alertscripts/sendmail.sh#设置脚本执行权限 五、测试Zabbix报警123456关闭Zabbix客户端服务service zabbix_agentd stop查看xxx@163.com邮箱，会收到报警邮件再开启Zabbix客户端服务service zabbix_agentd start查看xxx@163.com邮箱，会收到恢复邮件 使用外部邮箱账号发送报警邮件设置完成。至此，Zabbix邮件报警设置完成。 » 文章出自链接：http://www.osyunwei.com/archives/8113.html","categories":[{"name":"zabbix","slug":"zabbix","permalink":"/categories/zabbix/"}],"tags":[{"name":"监控","slug":"监控","permalink":"/tags/监控/"},{"name":"zabbix","slug":"zabbix","permalink":"/tags/zabbix/"}],"keywords":[{"name":"zabbix","slug":"zabbix","permalink":"/categories/zabbix/"}]},{"title":"Zabbix 源码安装配置","slug":"zabbix","date":"2016-11-02T08:53:58.969Z","updated":"2016-11-02T08:53:58.959Z","comments":true,"path":"2016/11/02/zabbix/","link":"","permalink":"/2016/11/02/zabbix/","excerpt":"zabbix（音同 zæbix）是一个基于WEB界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案。zabbix能监视各种网络参数，保证服务器系统的安全运营；并提供灵活的通知机制以让系统管理员快速定位/解决存在的各种问题。zabbix由2部分构成，zabbix server与可选组件zabbix agent。zabbix server可以通过SNMP，zabbix agent，ping，端口监视等方法提供对远程服务器/网络状态的监视，数据收集等功能，它可以运行在Linux，Solaris，HP-UX，AIX，Free BSD，Open BSD，OS X等平台上。123456Zabbix Server (收集数据)Zabbix Agent (监视)Net-SNMP (为了支持 SNMP(简单网络管理协议))Jabber (支持消息通知)OpenIPMI (监视)cURL (网页监视)","text":"zabbix（音同 zæbix）是一个基于WEB界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案。zabbix能监视各种网络参数，保证服务器系统的安全运营；并提供灵活的通知机制以让系统管理员快速定位/解决存在的各种问题。zabbix由2部分构成，zabbix server与可选组件zabbix agent。zabbix server可以通过SNMP，zabbix agent，ping，端口监视等方法提供对远程服务器/网络状态的监视，数据收集等功能，它可以运行在Linux，Solaris，HP-UX，AIX，Free BSD，Open BSD，OS X等平台上。123456Zabbix Server (收集数据)Zabbix Agent (监视)Net-SNMP (为了支持 SNMP(简单网络管理协议))Jabber (支持消息通知)OpenIPMI (监视)cURL (网页监视) ##第一、安装环境操作系统：centos6.5 64位Yum源：本地yum源IP地址：192.168.1.248DNS：192.168.1.1主机名：Alexzhou ##第二、软件包 ###1. Yum源1[root@Alexzhou]# yum install httpd httpd-devel mariadb mariadb-server mariadb-devel php php-mysql php-common php-gd php-xml ###2. 源码包1[root@Alexzhou ~]# wget http://downloads.sourceforge.net/project/zabbix/ZABBIX%20Latest%20Stable/2.4.7/zabbix-2.4.7.tar.gz?r=http%3A%2F%2Fwww.zabbix.com%2Fdownload.php&amp;ts=1452051496&amp;use_mirror=netix ##第三、开始安装 ###1.安装基础环境 安装LAMP123[root@Alexzhou ~]# yum install httpd httpd-devel mariadb mariadb-server mariadb-devel php php-mysql php-common php-gd php-xml php-bcmath php-mbstring OpenIPMI-devel libssh2-devel libxml2-devel unixODBC-devel net-snmp net-snmp-*[root@Alexzhou ~]# vim /etc/httpd/conf.d/vrt.conf 写入1234567891011121314&lt;Virtualhost *:80&gt; ServerName zabbix.allposs.com DocumentRoot /data/web/Monitor/zabbix/ DirectoryIndex index.php index.html &lt;Directory \"/data/web/Monitor/zabbix/\"&gt; Options FollowSymLinks Order allow,deny Allow from all Require all granted &lt;/Directory&gt; LogFormat \"%h %l %u %t %T \\\"%r\\\" %&gt;s %b \\\"%&#123;Referer&#125;i\\\" \\\"%&#123;User-Agent&#125;i\\\"\" common CustomLog /data/web/logs/Monitor/zabbix_access_log.log common ErrorLog /data/web/logs/Monitor/zabbix_error_log.log&lt;/VirtUalHost&gt; 注： apache配置文件请见Apache区域相关文档。开启服务并配置防火墙1234567891011[root@Alexzhou ~]# mkdir -p /data/web/Monitor/zabbix/[root@Alexzhou ~]# mkdir -p /data/web/logs/Monitor/[root@Alexzhou ~]# chcon -R -t httpd_sys_content_t /data/web/[root@Alexzhou ~]# chcon -R -t httpd_log_t /data/web/logs/[root@Alexzhou ~]# firewall-cmd --permanent --add-service=http[root@Alexzhou ~]# firewall-cmd --permanent --add-service=mysql[root@Alexzhou ~]# firewall-cmd --reload[root@Alexzhou ~]# systemctl enable mariadb.service [root@Alexzhou ~]# systemctl enable httpd.service [root@Alexzhou ~]# systemctl start mariadb.service[root@Alexzhou ~]# systemctl start httpd.service 初始化Mariadb1234[root@Alexzhou ~]# mysql_secure_installation#使用MySQL的初始化脚本，设置密码等。 [root@Alexzhou ~]# ntpdate cn.pool.ntp.org#同步时间，注意一定要与监控客户机一致，最好搭建一个NTP服务器，以保证时间同步。 ###2.安装zabbix1234567891011[root@Alexzhou ~]# wget http://downloads.sourceforge.net/project/zabbix/ZABBIX%20Latest%20Stable/2.4.7/zabbix-2.4.7.tar.gz?r=http%3A%2F%2Fwww.zabbix.com%2Fdownload.php&amp;ts=1452051496&amp;use_mirror=netix[root@Alexzhou ~]# mv zabbix-2.4.7.tar.gz\\?r\\=http\\:%2F%2Fwww.zabbix.com%2Fdownload.php zabbix-2.4.7.tar.gz[root@Alexzhou ~]# tar -zxvf zabbix-2.4.7.tar.gz[root@Alexzhou ~]# cd zabbix-2.4.7/[root@Alexzhou zabbix-2.4.7]# groupadd -g 201 zabbix[root@Alexzhou zabbix-2.4.7]# useradd -M -s /sbin/nologin -g zabbix zabbix[root@Alexzhou zabbix-2.4.7]# mysql -uroot -pMariaDB [(none)]&gt; create database zabbix character set utf8;MariaDB [(none)]&gt; grant all on zabbix.* to 'zabbix'@'localhost' identified by 'Password123' with grant option;MariaDB [(none)]&gt; flush privileges;MariaDB [(none)]&gt; quit 导入数据库，注意:导入数据库的先后顺序123[root@Alexzhou zabbix-2.4.7]# mysql -u'zabbix' -p'Password123' zabbix &lt;database/mysql/schema.sql[root@Alexzhou zabbix-2.4.7]# mysql -u'zabbix' -p'Password123' zabbix &lt;database/mysql/images.sql[root@Alexzhou zabbix-2.4.7]# mysql -u'zabbix' -p'Password123' zabbix &lt;database/mysql/data.sql 编译安装zabbix12345[root@Alexzhou zabbix-2.4.7]# yum -y groupinstall \"Development Tools\"[root@Alexzhou zabbix-2.4.7]# yum install net-snmp-devel[root@Alexzhou zabbix-2.4.7]# yum install curl-devel[root@Alexzhou zabbix-2.4.7]# ./configure --prefix=/usr/local/zabbix --sysconfdir=/etc/zabbix/ --enable-server --enable-proxy --enable-agent --with-net-snmp --with-libcurl --with-mysql=/usr/bin/mysql_config --with-net-snmp --with-ssh2 --enable-java --with-libcurl --with-libxml2 --with-ldap --with-openipmi --with-unixodbc--with-jabber --enable-ipv6 [root@Alexzhou zabbix-2.4.7]# make &amp;&amp; make install 注：1234567891011--prefix指定zabbix安装目录，--enable-server 支持zabbix服务器，--enable-agent支持zabbix代理，--enable-proxy 支持zabbix代理服务器，--with-mysql 使用MySQL客户端库可以选择指定路径mysql_config，--with-net-snmp 使用net snmp软件包,择性地指定路径NET SNMP配置, --with-libcurl 使用curl包。--with-openipmi 开启温度监控--enable-java 开启java监控 注意需要安装jdk 安装Jabber需要依赖于iksemel包的iksemel-devel包要使用自己发现协议必须开启snmp和fping 配置zabbix12345root@Alexzhou zabbix-2.4.7]# cp -Rf frontends/php/* /data/web/Monitor/zabbix/[root@Alexzhou zabbix-2.4.7]# usermod -G apache zabbix[root@Alexzhou zabbix-2.4.7]# chown -R apache.apache /data/web/Monitor/zabbix/[root@Alexzhou zabbix-2.4.7]# chown -R zabbix.zabbix /data/web/logs/Monitor/[root@Alexzhou zabbix-2.4.7]# vim /usr/lib/systemd/system/zabbix-server.service 写入12345678910111213[Unit]Description=Zabbix Monitor serverAfter=network.target[Service]Type=forkingPIDFile=/tmp/zabbix_server.pidEnvironment=\"CONFIG=/etc/zabbix/zabbix_server.conf\"ExecStart=/usr/local/zabbix/sbin/zabbix_server -c $&#123;CONFIG&#125;ExecStop=/bin/kill `cat $PIDFile`RemainAfterExit=yesRestart=always[Install]WantedBy=multi-user.target 修改配置文件1[root@Alexzhou zabbix-2.4.7]# vim /etc/zabbix/zabbix_server.conf 修改123456789ListenPort=10051LogFile=/data/web/logs/Monitor/zabbix_server.logPidFile=/tmp/zabbix_server.pidDBHost=localhostDBName=zabbixDBUser=zabbixDBPassword=Password123DBPort=3306AlertScriptsPath=/etc/zabbix/alertscripts 修改php.ini1[root@Alexzhou zabbix-2.4.7]# vim /etc/php.ini 修改1234post_max_size = 16Mmax_execution_time = 300max_input_time = 300date.timezone = Asia/Shanghai 添加客户端1[root@monitor Alexzhou]# vim /usr/lib/systemd/system/zabbix-agentd.service 写入1234567891011121314[Unit]Description=Zabbix Monitor agentdAfter=network.target[Service]Type=forkingPIDFile=/tmp/zabbix_agentd.pidEnvironment=\"CONFIG=/etc/zabbix/zabbix_agentd.conf\"ExecStart=/usr/local/zabbix/sbin/zabbix_agentd -c $&#123;CONFIG&#125;ExecStop=/bin/kill `cat $PIDFile`RemainAfterExit=yesRestart=always[Install]WantedBy=multi-user.target 修改配置文件1234567PidFile=/tmp/zabbix_agentd.pidLogFile=/data/web/logs/Monitor/zabbix_agentd.logServer=10.199.200.15ListenPort=10050ServerActive=127.0.0.1Hostname=Zabbix serverUnsafeUserParameters=1 设置防火墙12345[root@Alexzhou ~]# firewall-cmd --permanent --add-port=10051/tcp[root@Alexzhou ~]# firewall-cmd --permanent --add-port=10051/udp[root@Alexzhou ~]# firewall-cmd --permanent --add-port=10050/udp[root@Alexzhou ~]# firewall-cmd --permanent --add-port=10050/tcp[root@Alexzhou ~]# firewall-cmd --reload 开启服务1234[root@monitor ~]# chcon -u system_u /usr/lib/systemd/system/zabbix-*[root@monitor ~]# chcon -t systemd_unit_file_t /usr/lib/systemd/system/zabbix-*[root@monitor Monitor]# systemctl enable zabbix-agentd.service [root@monitor Monitor]# systemctl start zabbix-agentd.service 注意： 1.在配置相关服务的时候一定要注意selinux和防火墙设置，还有还有文件权限的设置。至此服务安装完成，打开界面进行下一步安装。","categories":[{"name":"zabbix","slug":"zabbix","permalink":"/categories/zabbix/"}],"tags":[{"name":"监控","slug":"监控","permalink":"/tags/监控/"},{"name":"zabbix","slug":"zabbix","permalink":"/tags/zabbix/"}],"keywords":[{"name":"zabbix","slug":"zabbix","permalink":"/categories/zabbix/"}]},{"title":"Zabbix 配置Fping","slug":"zabbixFping","date":"2016-11-02T04:38:31.168Z","updated":"2016-11-02T04:38:31.163Z","comments":true,"path":"2016/11/02/zabbixFping/","link":"","permalink":"/2016/11/02/zabbixFping/","excerpt":"本文是继之前安装后做的一些相关工作，所有前提在前文提到。这次是安装Fping利用ICMP协议进行判断网络主机是否存活。 [TOC] ##第一、安装环境 操作系统：CentOS6.5 X86_64 Yum源：163源 IP地址：Server:10.199.255.200 DNS：10.199.255.15 主机名：moniter ###1. 源码包1[root@Moniter ~]# wget http://www.fping.org/dist/fping-3.10.tar.gz","text":"本文是继之前安装后做的一些相关工作，所有前提在前文提到。这次是安装Fping利用ICMP协议进行判断网络主机是否存活。 [TOC] ##第一、安装环境 操作系统：CentOS6.5 X86_64 Yum源：163源 IP地址：Server:10.199.255.200 DNS：10.199.255.15 主机名：moniter ###1. 源码包1[root@Moniter ~]# wget http://www.fping.org/dist/fping-3.10.tar.gz ##第三、开始安装 ###1.下载Fping1[root@Moniter ~]# wget http://www.fping.org/dist/fping-3.10.tar.gz ###2.安装Fping 1234[root@Moniter ~]# tar -zxvf fping-3.10.tar.gz [root@Moniter ~]# cd fping-3.10[root@Moniter fping-3.10]# ./configure --prefix=/usr/local/Fping[root@Moniter fping-3.10]# make&amp;&amp;make install ###3.修改fping的权限12[root@Moniter ~]# chown root:root /usr/local/Fping/sbin/fping[root@Moniter ~]# chmod u+s /usr/local/Fping/sbin/fping ###4.zabbix配置1[root@Moniter fping-3.10]# vim /etc/zabbix/zabbix_server.conf 修改 FpingLocation=/usr/local/Fping/sbin/fping ###5.添加zabbix模板配置监控项ICMP_Loss 配置监控项ICMP_Ping 配置监控项ICMP_Response_Time 配置触发器ping失效 {Ping:icmpping.max(#3)}=0的意思是：在ping子集下的icmpping的最大值等于0配置触发器ping失效后平均值小于0.15 配置触发器Ping失效后最大时间为20 三者之间的依赖关系","categories":[{"name":"zabbix","slug":"zabbix","permalink":"/categories/zabbix/"}],"tags":[{"name":"监控","slug":"监控","permalink":"/tags/监控/"},{"name":"zabbix","slug":"zabbix","permalink":"/tags/zabbix/"}],"keywords":[{"name":"zabbix","slug":"zabbix","permalink":"/categories/zabbix/"}]},{"title":"Zabbix agent的安装部署","slug":"zabbixagent","date":"2016-11-01T09:21:17.459Z","updated":"2016-11-01T09:21:17.459Z","comments":true,"path":"2016/11/01/zabbixagent/","link":"","permalink":"/2016/11/01/zabbixagent/","excerpt":"zabbix server可以通过SNMP，zabbix agent，ping，端口监视等方法提供对远程服务器/网络状态的监视，数据收集等功能，它可以运行在Linux，Solaris，HP-UX，AIX，Free BSD，Open BSD，OS X等平台上。这里讲的是zabbix_agent的功能。","text":"zabbix server可以通过SNMP，zabbix agent，ping，端口监视等方法提供对远程服务器/网络状态的监视，数据收集等功能，它可以运行在Linux，Solaris，HP-UX，AIX，Free BSD，Open BSD，OS X等平台上。这里讲的是zabbix_agent的功能。 ##第一、安装环境 操作系统：CentOS6.5 X86_64 windows2008 Yum源：163源 IP地址： DNS： 主机名： ##第二、linux环境安装 ###1.前期准备123[root@knode1 ~]# groupadd -g 201 zabbix[root@knode1 ~]# useradd -M -s /sbin/nologin -g zabbix zabbix[root@knode1 ~]# yum -y groupinstall &quot;Development Tools&quot; ###2.安装zabbix_agentd12345[root@knode1 ~]# tar xf zabbix-2.4.7.tar.gz [root@knode1 ~]# cd zabbix-2.4.7[root@knode1 zabbix-2.4.7]# ./configure --prefix=/usr/local/zabbix_agent/ --enable-agent可以增加--sysconfdir=/etc/zabbix/把配置文件放到指定位置[root@knode1 zabbix-2.4.7]# make &amp;&amp; make install ###3.编辑配置文件12345678[root@knode1 zabbix-2.4.7]# vim /usr/local/zabbix_agent/etc/zabbix_agentd.conf修改为：Server=10.199.200.15ListenPort=10050ServerActive=10.199.200.15Hostname=knode1.allposs.comUser=zabbixUnsafeUserParameters=1 ###4.设置开机启动123456[root@knode1 zabbix-2.4.7]# ln -s /usr/local/zabbix_agent/sbin/zabbix_agentd /usr/local/sbin/zabbix_agentd[root@knode1 zabbix-2.4.7]# cp misc/init.d/fedora/core/zabbix_agentd /etc/init.d/[root@knode1 zabbix-2.4.7]# chmod u+x /etc/init.d/zabbix_agentd [root@knode1 zabbix-2.4.7]# chkconfig --add zabbix_agentd[root@knode1 zabbix-2.4.7]# chkconfig zabbix_agentd on[root@knode1 zabbix-2.4.7]# service zabbix_agentd start ##widows端安装 ###1.下载与解压地址: http://www.zabbix.com/downloads/2.4.0/zabbix_agents_2.4.0.win.zip解压zabbix_agents_2.4.0.win.zipconf目录存放是agent配置文件 bin文件存放windows下32位和64位安装程序 ###2.配置与安装 ####2.1配置zabbix agent相关配置找到conf下的配置文件 zabbix_agentd.win.conf，修改LogFile、Server、Hostname这三个参数。具体配置如下：1234LogFile=c:\\zabbix\\zabbix_agentd.log #日志存放位置Server=10.199.0.105 #zabbix服务器地址Hostname=WHUAFFS #本主机主机名ServerActive=10.199.0.105 #zabbix server地址 ####2.2 安装agent在cmd下执行以下命令：12cd c:\\zabbix\\win64\\zabbix_agentd.exe -c E:\\zabbix\\conf\\zabbix_agentd.win.conf –i ####2.3 启动agent客户端启动命令如下：1zabbix_agentd.exe -c E:\\zabbix\\conf\\zabbix_agentd.win.conf –s 启动的程序将以控制台的形式开启。判定是否启动可以查看启动的日志，或者使用netstat –an查看端口是否监听。","categories":[{"name":"zabbix","slug":"zabbix","permalink":"/categories/zabbix/"}],"tags":[{"name":"监控","slug":"监控","permalink":"/tags/监控/"},{"name":"zabbix","slug":"zabbix","permalink":"/tags/zabbix/"}],"keywords":[{"name":"zabbix","slug":"zabbix","permalink":"/categories/zabbix/"}]},{"title":"StartSSL免费https证书申请安装","slug":"SSL","date":"2016-11-01T09:21:13.718Z","updated":"2016-11-01T09:21:13.718Z","comments":true,"path":"2016/11/01/SSL/","link":"","permalink":"/2016/11/01/SSL/","excerpt":"StartSSL是比较早的免费https提供商，由于之前的沃通SSL证书被禁用后，目前只有StartSSL免费提供着第三方证书，当然你也可以选择购买StartSSL的收费版证书，由于本人自己测试以及使用着免费的StartSSL证书，所以废话不多说直接说明StartSSL的配置安装说明。 第一、StartSSL官方网站https://www.startssl.com/ 打开startssl官网新用户进行注册，老用户直接跳过注册，进行登录。","text":"StartSSL是比较早的免费https提供商，由于之前的沃通SSL证书被禁用后，目前只有StartSSL免费提供着第三方证书，当然你也可以选择购买StartSSL的收费版证书，由于本人自己测试以及使用着免费的StartSSL证书，所以废话不多说直接说明StartSSL的配置安装说明。 第一、StartSSL官方网站https://www.startssl.com/ 打开startssl官网新用户进行注册，老用户直接跳过注册，进行登录。第二、新注册StartSSL账号根据说明选择国家，填写注册自己的邮箱进行注册操作，验证码会发送至对应的邮箱。(按照注册流程下一步进行操作，楼主是已经注册的用户，直接点击LOGIN即可) 第三、选择SSL证书的应用类型、选择验证方式这里我们使用的是域名的方式进行验证填写好需要验证的域名或者子域名，然后点击确定，进行校验，选择需要验证的邮箱，并且受到邮箱的验证码填入validation code 点击验证 第四、申请免费域名SSL证书选择要申请的证书的合适类型，这里我们选择，Free User (Not Validated)，DV SSLCertificate证书类型填写申请的域名(最多支持5个子域名免费版的证书，否则需要购买更多)，填写CSR，有两种方式：1.选择下载tartComTool.exe 客户端去生成CSR2.使用命令行生成openssl req -newkey rsa:2048 -keyout yourname.key -out yourname.csr选择由IE Browser获得pfx格式证书，点击提交 第五、StartSSL免费SSL证书的下载和使用打开Certificate List这时候已经生成了刚刚申请的证书，说明下，这里我们默认注册的证书是1年如果需要增加证书使用年限在生成csr的时候修改证书的使用年限。证书的应用场景比较广泛比如nginx、ISS、ApacheServer等多服务器上部署，至此证书的申请使用已经完成，接下来就是各位部署到自己对应的服务器使用了，有兴趣的朋友可以自己申请部署试一试。","categories":[{"name":"SSL","slug":"SSL","permalink":"/categories/SSL/"}],"tags":[{"name":"科技","slug":"科技","permalink":"/tags/科技/"},{"name":"StartSSL","slug":"StartSSL","permalink":"/tags/StartSSL/"}],"keywords":[{"name":"SSL","slug":"SSL","permalink":"/categories/SSL/"}]},{"title":"nginx的编译安装","slug":"nginxbianyi","date":"2016-11-01T03:36:03.634Z","updated":"2016-11-01T03:36:03.630Z","comments":true,"path":"2016/11/01/nginxbianyi/","link":"","permalink":"/2016/11/01/nginxbianyi/","excerpt":"","text":"第一部分：在Nginx服务器上分别操作 一、关闭SElinux、配置防火墙1、vi /etc/selinux/config123456#SELINUX=enforcing #注释掉#SELINUXTYPE=targeted #注释掉SELINUX=disabled #增加:wq! #保存退出setenforce 0 #使配置立即生效 2、vi /etc/sysconfig/iptables #编辑1234567-A RH-Firewall-1-INPUT -d 224.0.0.18 -j ACCEPT #允许组播地址通信-A RH-Firewall-1-INPUT -p vrrp -j ACCEPT #允许VRRP（虚拟路由器冗余协）通信-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT #允许80端口通过防火墙:wq! #保存退出 /etc/init.d/iptables restart #重启防火墙使配置生效(或者)service iptables stop 二、安装Nginx 1、安装编译工具包（使用CentOS yum命令安装，安装的包比较多，方便以后配置lnmp环境）1yum install -y make apr* autoconf automake curl curl-devel gcc gcc-c++ gtk+-devel zlib-devel openssl openssl-devel pcre-devel gd kernel keyutils patch perl kernel-headers compat* cpp glibc libgomp libstdc++-devel keyutils-libs-devel libsepol-devel libselinux-devel krb5-devel libXpm* freetype freetype-devel freetype* fontconfig fontconfig-devel libjpeg* libpng* php-common php-gd gettext gettext-devel ncurses* libtool* libxml2 libxml2-devel patch policycoreutils bison 2、下载软件包（1）http://nginx.org/download/nginx-1.9.0.tar.gz #下载Nginx（2）https://sourceforge.net/projects/pcre/files/pcre/8.35/pcre-8.35.tar.gz/download #下载pcre （支持nginx伪静态）上传以上软件包到/usr/local/ 目录 3、安装pcre123456cd /usr/local/srcmkdir /usr/local/pcre #创建安装目录tar -zxvf pcre-8.35.tar.gzcd pcre-8.35./configure --prefix=/usr/local/pcre make &amp;&amp; make install 4、安装Nginx123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130cd /usr/local/groupadd www useradd -g www www -s /bin/false tar -zxvf nginx-1.9.0.tar.gz cd nginx-1.9.0*带参数编译根据自己使用nginx的具体情况安装对应模块*./configure --prefix=/etc/nginx --sbin-path=/usr/sbin/nginx --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/run/nginx.pid --lock-path=/var/run/nginx.lock --http-client-body-temp-path=/var/cache/nginx/client_temp --http-proxy-temp-path=/var/cache/nginx/proxy_temp --http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp --http-scgi-temp-path=/var/cache/nginx/scgi_temp --user=nginx --group=nginx --with-http_ssl_module --with-http_realip_module --with-http_addition_module --with-http_sub_module --with-http_dav_module --with-http_flv_module --with-http_mp4_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_random_index_module --with-http_secure_link_module --with-http_stub_status_module --with-http_auth_request_module --with-mail_ssl_module --with-file-aiomake &amp;&amp; make install设置nginx开启启动vi /etc/rc.d/init.d/nginx #编辑启动文件添加下面内容#!/bin/sh## nginx - this script starts and stops the nginx daemin## Comments to support chkconfig on RedHat Linux# chkconfig: 2345 64 36# description: nginx# Comments to support LSB init script conventions### BEGIN INIT INFO# Provides: nginx# Required-Start: $local_fs $network $remote_fs# Should-Start: ypbind nscd ldap ntpd xntpd# Required-Stop: $local_fs $network $remote_fs# Default-Start: 2 3 4 5# Default-Stop: 0 1 6# Short-Description: start and stop nginx### END INIT INFO# Source function library.. /etc/init.d/functionsnginx=&quot;/usr/sbin/nginx &quot;prog=$(basename $nginx)NGINX_CONF_FILE=&quot;/etc/nginx/nginx.conf&quot;lockfile=/var/lock/subsys/nginxstart() &#123; [ -x $nginx ] || exit 5 [ -f $NGINX_CONF_FILE ] || exit 6 echo -n $&quot;Starting $prog: &quot; daemon $nginx -c $NGINX_CONF_FILE retval=$? echo [ $retval -eq 0 ] &amp;&amp; touch $lockfile return $retval&#125;stop() &#123; echo -n $&quot;Stopping $prog: &quot; killproc $prog -QUIT retval=$? echo [ $retval -eq 0 ] &amp;&amp; rm -f $lockfile return $retval&#125;restart() &#123; configtest || return $? stop sleep 1 start&#125;reload() &#123; configtest || return $? echo -n $&quot;Reloading $prog: &quot; killproc $nginx -HUP RETVAL=$? echo&#125;force_reload() &#123; restart&#125;configtest() &#123; $nginx -t -c $NGINX_CONF_FILE&#125;rh_status() &#123; status $prog&#125;rh_status_q() &#123; rh_status &gt;/dev/null 2&gt;&amp;1&#125;case &quot;$1&quot; in start) rh_status_q &amp;&amp; exit 0 $1 ;; stop) rh_status_q || exit 0 $1 ;; restart|configtest) $1 ;; reload) rh_status_q || exit 7 $1 ;; force-reload) force_reload ;; status) rh_status ;; condrestart|try-restart) rh_status_q || exit 0 ;; *) echo $&quot;Usage: $0 &#123;start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest&#125;&quot; exit 2esac*************************************************************************************************:wq! #保存退出chmod 775 /etc/rc.d/init.d/nginx #赋予文件执行权限chkconfig nginx on #设置开机启动/etc/rc.d/init.d/nginx restart #重新启动Nginxservice nginx restart************************************************************************************************* 三、配置Nginx1cp /etc/nginx/nginx.conf /etc/nginx/nginx.conf.bak #备份nginx配置文件 1、设置nginx运行账1234567891011121314151617vi /etc/nginx/nginx.conf #编辑，修改找到server，在上面一行添加如下内容：server &#123;listen 80 default;server_name _;location / &#123;root html;return 404;&#125;location ~ /.ht &#123;deny all;&#125;&#125;:wq! #保存退出service nginx restart这样设置之后，空主机头访问会直接跳转到nginx404错误页面。 3、添加nginx虚拟主机包含文件12345678910111213141516171819cd /etc/nginx/mkdir vhost vi /etc/nginx/nginx.conf找到上一步添加的代码，在最后添加如下内容：include vhost/*.conf;:wq! #保存退出例如：server &#123;listen 80 default;server_name _;location / &#123;root html;return 404;&#125;location ~ /.ht &#123;deny all;&#125;&#125;include vhost/*.conf; 4、添加Web服务器列表文件123456cd /etc/nginx/ #进入目录 touch mysvrhost.conf #建立文件vi /etc/nginx/nginx.conf #编辑找到上一步添加的代码，在下面添加一行include mysvrhost.conf;:wq! #保存退出 5、设置nginx全局参数1234567891011121314151617181920212223vi /etc/nginx/nginx.confworker_processes 2; # 工作进程数,为CPU的核心数或者两倍events&#123;use epoll; #增加worker_connections 65535; #修改为65535，最大连接数。&#125;********以下代码在http &#123; 部分增加与修改********server_names_hash_bucket_size 128; #增加client_header_buffer_size 32k; #增加large_client_header_buffers 4 32k; #增加client_max_body_size 300m; #增加tcp_nopush on; #修改为onkeepalive_timeout 60; #修改为60tcp_nodelay on; #增加server_tokens off; #增加，不显示nginx版本信息gzip on; #修改为ongzip_min_length 1k; #增加gzip_buffers 4 16k; #增加gzip_http_version 1.1; #增加gzip_comp_level 2; #增加gzip_types text/plain application/x-javascript text/css application/xml; #增加gzip_vary on; #增加 6、设置Web服务器列表1234567cd /etc/nginx #进入目录vi mysvrhost.conf #编辑，添加以下代码upstream osyunweihost &#123;server 192.168.21.127:80 weight=1 max_fails=2 fail_timeout=30s;server 192.168.21.128:80 weight=1 max_fails=2 fail_timeout=30s;ip_hash;&#125; 7、新建虚拟主机配置文件1234567891011121314151617181920212223242526272829```cd /etc/nginx/vhost touch osyunwei.conf #建立虚拟主机配置文件vi osyunwei.conf #编辑log_format access &apos;$remote_addr - $remote_user [$time_local] $request &apos;&apos;&quot;$status&quot; $body_bytes_sent &quot;$http_referer&quot; &apos;&apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;server&#123;listen 80;server_name www.a.com www.b.com;location /&#123;proxy_next_upstream http_502 http_504 error timeout invalid_header;proxy_pass http://osyunweihost;#proxy_redirect off;proxy_set_header Host $host;proxy_set_header X-Forwarded-For $remote_addr;&#125;location /NginxStatus &#123;stub_status on;access_log on;auth_basic &quot;NginxStatus&quot;;######auth_basic_user_file pwd;&#125;access_log /usr/local/nginx/logs/access.log access;&#125;:wq! #保存配置service nginx restart #重启nginx 至此nginx安装配置基本完成","categories":[{"name":"nginx","slug":"nginx","permalink":"/categories/nginx/"}],"tags":[{"name":"科技","slug":"科技","permalink":"/tags/科技/"},{"name":"nginx","slug":"nginx","permalink":"/tags/nginx/"}],"keywords":[{"name":"nginx","slug":"nginx","permalink":"/categories/nginx/"}]},{"title":"nginx配置SSL双向认证","slug":"nginxrenzhen","date":"2016-11-01T03:10:04.106Z","updated":"2016-11-01T03:10:04.100Z","comments":true,"path":"2016/11/01/nginxrenzhen/","link":"","permalink":"/2016/11/01/nginxrenzhen/","excerpt":"https双向认证 双向认证SSL 协议的具体通讯过程，这种情况要求服务器和客户端双方都有证书。 单向认证SSL 协议不需要客户端拥有CA证书，以及在协商对称密码方案，对称通话密钥时，服务器发送给客户端的是没有加过密的（这并不影响SSL过程的安全性）密码方案。这样，双方具体的通讯内容，就是加密过的数据。如果有第三方攻击，获得的只是加密的数据，第三方要获得有用的信息，就需要对加密的数据进行解密，这时候的安全就依赖于密码方案的安全。而幸运的是，目前所用的密码方案，只要通讯密钥长度足够的长，就足够的安全。这也是我们强调要求使用128位加密通讯的原因。一般Web应用都是采用单向认证的，原因很简单，用户数目广泛，且无需做在通讯层做用户身份验证，一般都在应用逻辑层来保证用户的合法登入。但如果是企业应用对接，情况就不一样，可能会要求对客户端（相对而言）做身份验证。这时就需要做双向认证。","text":"https双向认证 双向认证SSL 协议的具体通讯过程，这种情况要求服务器和客户端双方都有证书。 单向认证SSL 协议不需要客户端拥有CA证书，以及在协商对称密码方案，对称通话密钥时，服务器发送给客户端的是没有加过密的（这并不影响SSL过程的安全性）密码方案。这样，双方具体的通讯内容，就是加密过的数据。如果有第三方攻击，获得的只是加密的数据，第三方要获得有用的信息，就需要对加密的数据进行解密，这时候的安全就依赖于密码方案的安全。而幸运的是，目前所用的密码方案，只要通讯密钥长度足够的长，就足够的安全。这也是我们强调要求使用128位加密通讯的原因。一般Web应用都是采用单向认证的，原因很简单，用户数目广泛，且无需做在通讯层做用户身份验证，一般都在应用逻辑层来保证用户的合法登入。但如果是企业应用对接，情况就不一样，可能会要求对客户端（相对而言）做身份验证。这时就需要做双向认证。 1、安装nginx参考《nginx安装》：http://www.msbgn.cn/2016/11/01/nginxbianyi/ 2、使用openssl实现证书中心由于是使用openssl架设私有证书中心，因此要保证以下字段在证书中心的证书、服务端证书、客户端证书中都相同 代码块12345Country Name State or Province Name Locality Name Organization Name Organizational Unit Name 编辑证书中心配置文件 12345678910111213141516171819202122vim /etc/pki/tls/openssl.cnf[ ca ]default_ca = CA_default # The default ca section####################################################################[ CA_default ]dir = /etc/pki/CA # Where everything is keptcerts = $dir/certs # Where the issued certs are keptcrl_dir = $dir/crl # Where the issued crl are keptdatabase = $dir/index.txt # database index file.#unique_subject = no # Set to &apos;no&apos; to allow creation of # several ctificates with same subject.new_certs_dir = $dir/newcerts # default place for new certs.certificate = $dir/cacert.pem # The CA certificateserial = $dir/serial # The current serial numbercrlnumber = $dir/crlnumber # the current crl number # must be commented out to leave a V1 CRLcrl = $dir/crl.pem # The current CRLprivate_key = $dir/private/cakey.pem# The private keyRANDFILE = $dir/private/.rand # private random number filex509_extensions = usr_cert # The extentions to add to the cert# Comment out the following two lines for the &quot;traditional&quot;# (and highly broken) format.name_opt = ca_default # Subject Name optionscert_opt = ca_default # Certificate field options 创建证书私钥12cd /etc/pki/CA/private(umask 077;openssl genrsa -out cakey.pem 2048) 生成自签证书（我这里申请的自签证书为10年，如有报错，请检查vim /etc/pki/tls/openssl.cnf）12cd /etc/pki/CA/openssl req -new -x509 -key private/cakey.pem -out cacert.pem -days=3655 3、创建服务器证书12345mkdir /usr/local/nginx/ssl cd /usr/local/nginx/ssl (umask 077;openssl genrsa -out nginx.key 1024) openssl req -new -key nginx.key -out nginx.csr openssl ca -in nginx.csr -out nginx.crt -days=3650 ##4、创建客户端浏览器证书 12345(umask 077;openssl genrsa -out client.key 1024) openssl req -new -key client.key -out client.csr openssl ca -in client.csr -out client.crt -days=3650 将文本格式的证书转换成可以导入浏览器的证书，最好是设置客户端证书访问密码，并且报存好客户端证书p12 openssl pkcs12 -export -clcerts -in client.crt -inkey client.key -out client.p12 5、配置nginx服务器验证12345678vim /usr/local/nginx/conf/nginx.conf ssl on; ssl_certificate /usr/local/nginx/ssl/nginx.crt; ssl_certificate_key /usr/local/nginx/ssl/nginx.key; ssl_client_certificate /usr/local/nginx/ssl/cacert.pem; ssl_session_timeout 5m; #ssl_verify_client on; 服务器验证客户端，暂时不开启，让没有证书的客户端可以访问，先完成单向验证 ssl_protocols SSLv2 SSLv3 TLSv1; 6、打开浏览器安装客户端证书点击安装生成的证书下一步输入证书密码(密码就是之前生成证书时候设置的密码)，下一步安装成功。 7、验证证书的使用没有导入证书访问没有导入浏览器安装的证书显示为400 导入证书访问注意:安装证书的时候，记得安装完成证书关闭浏览器重新打开访问。感谢阅读这份帮助文档。请点击右上角开启分享体验吧。","categories":[{"name":"nginx","slug":"nginx","permalink":"/categories/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"/tags/nginx/"},{"name":"ssl","slug":"ssl","permalink":"/tags/ssl/"}],"keywords":[{"name":"nginx","slug":"nginx","permalink":"/categories/nginx/"}]},{"title":"nginx的URL重定向功能","slug":"nginxw","date":"2016-10-25T07:21:39.375Z","updated":"2016-10-25T07:21:39.369Z","comments":true,"path":"2016/10/25/nginxw/","link":"","permalink":"/2016/10/25/nginxw/","excerpt":"location 语法:location [=|~|~|^~] /uri/ { … }默认:否这个指令随URL不同而接受不同的结构。你可以配置使用常规字符串和正则表达式。如果使用正则表达式，你必须使用 ~ 前缀选择不区分大小写的匹配或者 ~ 选择区分大小写的匹配。 确定 哪个location 指令匹配一个特定指令，常规字符串第一个测试。常规字符串匹配请求的开始部分并且区分大小写，最明确的匹配将会被使用（查看下文明白 nginx 怎么确定它）。然后正则表达式按照配置文件里的顺序测试。找到第一个比配的正则表达式将停止搜索。如果没有找到匹配的正则表达式，使用常规字符串的结果。 有两个方法修改这个行为。第一个方法是使用 “=”前缀，将只执行严格匹配。如果这个查询匹配，那么将停止搜索并立即处理这个请求。例子：如果经常发生”/”请求，那么使用 “location = /” 将加速处理这个请求。 第二个是使用 ^~ 前缀。如果把这个前缀用于一个常规字符串那么告诉nginx 如果路径匹配那么不测试正则表达式。 而且它重要在于 NGINX 做比较没有 URL 编码，所以如果你有一个 URL 链接’/images/%20/test’ , 那么使用 “images/ /test” 限定location。","text":"location 语法:location [=|~|~|^~] /uri/ { … }默认:否这个指令随URL不同而接受不同的结构。你可以配置使用常规字符串和正则表达式。如果使用正则表达式，你必须使用 ~ 前缀选择不区分大小写的匹配或者 ~ 选择区分大小写的匹配。 确定 哪个location 指令匹配一个特定指令，常规字符串第一个测试。常规字符串匹配请求的开始部分并且区分大小写，最明确的匹配将会被使用（查看下文明白 nginx 怎么确定它）。然后正则表达式按照配置文件里的顺序测试。找到第一个比配的正则表达式将停止搜索。如果没有找到匹配的正则表达式，使用常规字符串的结果。 有两个方法修改这个行为。第一个方法是使用 “=”前缀，将只执行严格匹配。如果这个查询匹配，那么将停止搜索并立即处理这个请求。例子：如果经常发生”/”请求，那么使用 “location = /” 将加速处理这个请求。 第二个是使用 ^~ 前缀。如果把这个前缀用于一个常规字符串那么告诉nginx 如果路径匹配那么不测试正则表达式。 而且它重要在于 NGINX 做比较没有 URL 编码，所以如果你有一个 URL 链接’/images/%20/test’ , 那么使用 “images/ /test” 限定location。总结，指令按下列顺序被接受: = 前缀的指令严格匹配这个查询。如果找到，停止搜索。 剩下的常规字符串，长的在前。如果这个匹配使用 ^~ 前缀，搜索停止。 正则表达式，按配置文件里的顺序。 如果第三步产生匹配，则使用这个结果。否则使用第二步的匹配结果。 例子： location = / {＃ 只匹配 / 查询。[ configuration A ]} location / {#匹配任何查询，因为所有请求都已 / 开头。但是正则表达式规则和长的块规则将被优先和查询匹配。[ configuration B ]} location ^~ /images/ {# 匹配任何已 /images/ 开头的任何查询并且停止搜索。任何正则表达式将不会被测试。[ configuration C ]} location ~ .(gif|jpg|jpeg)$ {*# 匹配任何已 gif、jpg 或 jpeg 结尾的请求。然而所有 /images/ 目录的请求将使用 Configuration C。[ configuration D ]} 例子请求: / -&gt; configuration A /documents/document.html -&gt; configuration B /images/1.gif -&gt; configuration C /documents/1.jpg -&gt; configuration D 注意：按任意顺序定义这4个配置结果将仍然一样。","categories":[{"name":"nginx","slug":"nginx","permalink":"/categories/nginx/"}],"tags":[{"name":"科技","slug":"科技","permalink":"/tags/科技/"},{"name":"nginx","slug":"nginx","permalink":"/tags/nginx/"}],"keywords":[{"name":"nginx","slug":"nginx","permalink":"/categories/nginx/"}]}]}